// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(zcashFFI)
    import zcashFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_zcash_e53_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_zcash_e53_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol SecpSecretKeyProtocol {
    func serializeSecret() -> [UInt8]
}

public class SecpSecretKey: SecpSecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_SecpSecretKey_new(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_SecpSecretKey_object_free(pointer, $0) }
    }

    public func serializeSecret() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_SecpSecretKey_serialize_secret(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeSecpSecretKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecpSecretKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecpSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecpSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecpSecretKey {
        return SecpSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecpSecretKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeSecpSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecpSecretKey {
    return try FfiConverterTypeSecpSecretKey.lift(pointer)
}

public func FfiConverterTypeSecpSecretKey_lower(_ value: SecpSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecpSecretKey.lower(value)
}

public protocol TestSupportProtocol {
    func getAsU8Array(key: String) -> [UInt8]

    func getAsU32Array(key: String) -> [UInt32]

    func getAsU64Array(key: String) -> [UInt64]

    func getAsU32(key: String) -> UInt32

    func getAsU64(key: String) -> UInt64

    func getAsString(key: String) -> String
}

public class TestSupport: TestSupportProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_TestSupport_object_free(pointer, $0) }
    }

    public static func fromCsvFile() -> TestSupport {
        return TestSupport(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_TestSupport_from_csv_file($0)
            })
    }

    public func getAsU8Array(key: String) -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_TestSupport_get_as_u8_array(self.pointer,
                                                          FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU32Array(key: String) -> [UInt32] {
        return try! FfiConverterSequenceUInt32.lift(
            try!
                rustCall {
                    zcash_e53_TestSupport_get_as_u32_array(self.pointer,
                                                           FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU64Array(key: String) -> [UInt64] {
        return try! FfiConverterSequenceUInt64.lift(
            try!
                rustCall {
                    zcash_e53_TestSupport_get_as_u64_array(self.pointer,
                                                           FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU32(key: String) -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_TestSupport_get_as_u32(self.pointer,
                                                     FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU64(key: String) -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    zcash_e53_TestSupport_get_as_u64(self.pointer,
                                                     FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsString(key: String) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_TestSupport_get_as_string(self.pointer,
                                                        FfiConverterString.lower(key), $0)
                }
        )
    }
}

public struct FfiConverterTypeTestSupport: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TestSupport

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TestSupport {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TestSupport, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TestSupport {
        return TestSupport(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TestSupport) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeTestSupport_lift(_ pointer: UnsafeMutableRawPointer) throws -> TestSupport {
    return try FfiConverterTypeTestSupport.lift(pointer)
}

public func FfiConverterTypeTestSupport_lower(_ value: TestSupport) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTestSupport.lower(value)
}

public protocol ZcashAccountPrivKeyProtocol {
    func toAccountPubkey() -> ZcashAccountPubKey

    func deriveExternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey

    func deriveInternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey

    func toBytes() -> [UInt8]
}

public class ZcashAccountPrivKey: ZcashAccountPrivKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashAccountPrivKey_object_free(pointer, $0) }
    }

    public static func fromSeed(params: ZcashConsensusParameters, seed: [UInt8], accountId: ZcashAccountId) throws -> ZcashAccountPrivKey {
        return try ZcashAccountPrivKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPrivKey_from_seed(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterSequenceUInt8.lower(seed),
                    FfiConverterTypeZcashAccountId.lower(accountId), $0
                )
            })
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashAccountPrivKey {
        return try ZcashAccountPrivKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPrivKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func fromExtendedPrivkey(key: ZcashExtendedPrivKey) -> ZcashAccountPrivKey {
        return ZcashAccountPrivKey(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashAccountPrivKey_from_extended_privkey(
                    FfiConverterTypeZcashExtendedPrivKey.lower(key), $0
                )
            })
    }

    public func toAccountPubkey() -> ZcashAccountPubKey {
        return try! FfiConverterTypeZcashAccountPubKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAccountPrivKey_to_account_pubkey(self.pointer, $0)
                }
        )
    }

    public func deriveExternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey {
        return try FfiConverterTypeSecpSecretKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPrivKey_derive_external_secret_key(self.pointer,
                                                                         FfiConverterUInt32.lower(childIndex), $0)
            }
        )
    }

    public func deriveInternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey {
        return try FfiConverterTypeSecpSecretKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key(self.pointer,
                                                                         FfiConverterUInt32.lower(childIndex), $0)
            }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAccountPrivKey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAccountPrivKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAccountPrivKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountPrivKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAccountPrivKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPrivKey {
        return ZcashAccountPrivKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAccountPrivKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAccountPrivKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPrivKey {
    return try FfiConverterTypeZcashAccountPrivKey.lift(pointer)
}

public func FfiConverterTypeZcashAccountPrivKey_lower(_ value: ZcashAccountPrivKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAccountPrivKey.lower(value)
}

public protocol ZcashAccountPubKeyProtocol {
    func deriveExternalIvk() throws -> ZcashExternalIvk

    func deriveInternalIvk() throws -> ZcashInternalIvk

    func ovksForShielding() -> ZcashInternalOvkExternalOvk

    func internalOvk() -> ZcashInternalOvk

    func externalOvk() -> ZcashExternalOvk

    func serialize() -> [UInt8]
}

public class ZcashAccountPubKey: ZcashAccountPubKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPubKey_new(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashAccountPubKey_object_free(pointer, $0) }
    }

    public func deriveExternalIvk() throws -> ZcashExternalIvk {
        return try FfiConverterTypeZcashExternalIvk.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPubKey_derive_external_ivk(self.pointer, $0)
            }
        )
    }

    public func deriveInternalIvk() throws -> ZcashInternalIvk {
        return try FfiConverterTypeZcashInternalIvk.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAccountPubKey_derive_internal_ivk(self.pointer, $0)
            }
        )
    }

    public func ovksForShielding() -> ZcashInternalOvkExternalOvk {
        return try! FfiConverterTypeZcashInternalOvkExternalOvk.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAccountPubKey_ovks_for_shielding(self.pointer, $0)
                }
        )
    }

    public func internalOvk() -> ZcashInternalOvk {
        return try! FfiConverterTypeZcashInternalOvk.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAccountPubKey_internal_ovk(self.pointer, $0)
                }
        )
    }

    public func externalOvk() -> ZcashExternalOvk {
        return try! FfiConverterTypeZcashExternalOvk.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAccountPubKey_external_ovk(self.pointer, $0)
                }
        )
    }

    public func serialize() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAccountPubKey_serialize(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAccountPubKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAccountPubKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountPubKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAccountPubKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPubKey {
        return ZcashAccountPubKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAccountPubKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAccountPubKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPubKey {
    return try FfiConverterTypeZcashAccountPubKey.lift(pointer)
}

public func FfiConverterTypeZcashAccountPubKey_lower(_ value: ZcashAccountPubKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAccountPubKey.lower(value)
}

public protocol ZcashAmountProtocol {
    func value() -> Int64
}

public class ZcashAmount: ZcashAmountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(amount: Int64) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAmount_new(
                    FfiConverterInt64.lower(amount), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashAmount_object_free(pointer, $0) }
    }

    public static func zero() -> ZcashAmount {
        return ZcashAmount(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashAmount_zero($0)
            })
    }

    public func value() -> Int64 {
        return try! FfiConverterInt64.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAmount_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAmount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAmount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAmount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAmount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAmount {
        return ZcashAmount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAmount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAmount {
    return try FfiConverterTypeZcashAmount.lift(pointer)
}

public func FfiConverterTypeZcashAmount_lower(_ value: ZcashAmount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAmount.lower(value)
}

public protocol ZcashAnchorProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashAnchor: ZcashAnchorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashAnchor_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashAnchor {
        return try ZcashAnchor(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashAnchor_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashAnchor_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAnchor: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAnchor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAnchor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAnchor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAnchor {
        return ZcashAnchor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAnchor) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAnchor_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAnchor {
    return try FfiConverterTypeZcashAnchor.lift(pointer)
}

public func FfiConverterTypeZcashAnchor_lower(_ value: ZcashAnchor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAnchor.lower(value)
}

public protocol ZcashBlockHeightProtocol {
    func value() -> UInt32
}

public class ZcashBlockHeight: ZcashBlockHeightProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(v: UInt32) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashBlockHeight_new(
                    FfiConverterUInt32.lower(v), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashBlockHeight_object_free(pointer, $0) }
    }

    public func value() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_ZcashBlockHeight_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashBlockHeight: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashBlockHeight

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBlockHeight {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashBlockHeight, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockHeight {
        return ZcashBlockHeight(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashBlockHeight) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashBlockHeight_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockHeight {
    return try FfiConverterTypeZcashBlockHeight.lift(pointer)
}

public func FfiConverterTypeZcashBlockHeight_lower(_ value: ZcashBlockHeight) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashBlockHeight.lower(value)
}

public protocol ZcashCommitmentTreeProtocol {
    func append(node: ZcashSaplingNode) throws
}

public class ZcashCommitmentTree: ZcashCommitmentTreeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashCommitmentTree_object_free(pointer, $0) }
    }

    public static func empty() -> ZcashCommitmentTree {
        return ZcashCommitmentTree(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashCommitmentTree_empty($0)
            })
    }

    public func append(node: ZcashSaplingNode) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashCommitmentTree_append(self.pointer,
                                                     FfiConverterTypeZcashSaplingNode.lower(node), $0)
            }
    }
}

public struct FfiConverterTypeZcashCommitmentTree: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashCommitmentTree

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashCommitmentTree {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashCommitmentTree, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashCommitmentTree {
        return ZcashCommitmentTree(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashCommitmentTree) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashCommitmentTree_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashCommitmentTree {
    return try FfiConverterTypeZcashCommitmentTree.lift(pointer)
}

public func FfiConverterTypeZcashCommitmentTree_lower(_ value: ZcashCommitmentTree) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashCommitmentTree.lower(value)
}

public protocol ZcashDiversifiableFullViewingKeyProtocol {
    func toBytes() -> [UInt8]

    func fvk() -> ZcashFullViewingKey

    func toNk(scope: ZcashScope) -> ZcashNullifierDerivingKey

    func toIvk(scope: ZcashScope) -> ZcashSaplingIvk

    func toOvk(scope: ZcashScope) -> ZcashOutgoingViewingKey

    func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress?

    func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress?

    func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func diversifiedAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?

    func changeAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func diversifiedChangeAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?

    func decryptDiversifier(addr: ZcashPaymentAddress) -> ZcashDiversifierIndexAndScope?
}

public class ZcashDiversifiableFullViewingKey: ZcashDiversifiableFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashDiversifiableFullViewingKey {
        return try ZcashDiversifiableFullViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func fvk() -> ZcashFullViewingKey {
        return try! FfiConverterTypeZcashFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_fvk(self.pointer, $0)
                }
        )
    }

    public func toNk(scope: ZcashScope) -> ZcashNullifierDerivingKey {
        return try! FfiConverterTypeZcashNullifierDerivingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_to_nk(self.pointer,
                                                                     FfiConverterTypeZcashScope.lower(scope), $0)
                }
        )
    }

    public func toIvk(scope: ZcashScope) -> ZcashSaplingIvk {
        return try! FfiConverterTypeZcashSaplingIvk.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk(self.pointer,
                                                                      FfiConverterTypeZcashScope.lower(scope), $0)
                }
        )
    }

    public func toOvk(scope: ZcashScope) -> ZcashOutgoingViewingKey {
        return try! FfiConverterTypeZcashOutgoingViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk(self.pointer,
                                                                      FfiConverterTypeZcashScope.lower(scope), $0)
                }
        )
    }

    public func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_address(self.pointer,
                                                                       FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress? {
        return try! FfiConverterOptionTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_find_address(self.pointer,
                                                                            FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_default_address(self.pointer, $0)
                }
        )
    }

    public func diversifiedAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address(self.pointer,
                                                                                   FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func changeAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_change_address(self.pointer, $0)
                }
        )
    }

    public func diversifiedChangeAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address(self.pointer,
                                                                                          FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func decryptDiversifier(addr: ZcashPaymentAddress) -> ZcashDiversifierIndexAndScope? {
        return try! FfiConverterOptionTypeZcashDiversifierIndexAndScope.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier(self.pointer,
                                                                                   FfiConverterTypeZcashPaymentAddress.lower(addr), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashDiversifiableFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDiversifiableFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifiableFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDiversifiableFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifiableFullViewingKey {
        return ZcashDiversifiableFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDiversifiableFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDiversifiableFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifiableFullViewingKey {
    return try FfiConverterTypeZcashDiversifiableFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashDiversifiableFullViewingKey_lower(_ value: ZcashDiversifiableFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDiversifiableFullViewingKey.lower(value)
}

public protocol ZcashDiversifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashDiversifier: ZcashDiversifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(bytes: [UInt8]) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashDiversifier_new(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashDiversifier_object_free(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashDiversifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDiversifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDiversifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifier {
        return ZcashDiversifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDiversifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDiversifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifier {
    return try FfiConverterTypeZcashDiversifier.lift(pointer)
}

public func FfiConverterTypeZcashDiversifier_lower(_ value: ZcashDiversifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDiversifier.lower(value)
}

public protocol ZcashDiversifierIndexProtocol {
    func increment() throws

    func toU32() throws -> UInt32

    func toBytes() -> [UInt8]
}

public class ZcashDiversifierIndex: ZcashDiversifierIndexProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashDiversifierIndex_new($0)
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashDiversifierIndex_object_free(pointer, $0) }
    }

    public static func fromU32(i: UInt32) -> ZcashDiversifierIndex {
        return ZcashDiversifierIndex(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashDiversifierIndex_from_u32(
                    FfiConverterUInt32.lower(i), $0
                )
            })
    }

    public static func fromU64(i: UInt64) -> ZcashDiversifierIndex {
        return ZcashDiversifierIndex(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashDiversifierIndex_from_u64(
                    FfiConverterUInt64.lower(i), $0
                )
            })
    }

    public func increment() throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashDiversifierIndex_increment(self.pointer, $0)
            }
    }

    public func toU32() throws -> UInt32 {
        return try FfiConverterUInt32.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashDiversifierIndex_to_u32(self.pointer, $0)
            }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashDiversifierIndex_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashDiversifierIndex: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDiversifierIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifierIndex {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDiversifierIndex, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifierIndex {
        return ZcashDiversifierIndex(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDiversifierIndex) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDiversifierIndex_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifierIndex {
    return try FfiConverterTypeZcashDiversifierIndex.lift(pointer)
}

public func FfiConverterTypeZcashDiversifierIndex_lower(_ value: ZcashDiversifierIndex) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDiversifierIndex.lower(value)
}

public protocol ZcashExpandedSpendingKeyProtocol {
    func proofGenerationKey() -> ZcashProofGenerationKey

    func toBytes() -> [UInt8]
}

public class ZcashExpandedSpendingKey: ZcashExpandedSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExpandedSpendingKey_object_free(pointer, $0) }
    }

    public static func fromSpendingKey(sk: [UInt8]) -> ZcashExpandedSpendingKey {
        return ZcashExpandedSpendingKey(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashExpandedSpendingKey_from_spending_key(
                    FfiConverterSequenceUInt8.lower(sk), $0
                )
            })
    }

    public static func fromBytes(b: [UInt8]) throws -> ZcashExpandedSpendingKey {
        return try ZcashExpandedSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExpandedSpendingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(b), $0
                )
            })
    }

    public func proofGenerationKey() -> ZcashProofGenerationKey {
        return try! FfiConverterTypeZcashProofGenerationKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExpandedSpendingKey_proof_generation_key(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExpandedSpendingKey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExpandedSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExpandedSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExpandedSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExpandedSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExpandedSpendingKey {
        return ZcashExpandedSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExpandedSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExpandedSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExpandedSpendingKey {
    return try FfiConverterTypeZcashExpandedSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashExpandedSpendingKey_lower(_ value: ZcashExpandedSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExpandedSpendingKey.lower(value)
}

public protocol ZcashExtendedFullViewingKeyProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func toBytes() -> [UInt8]

    func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress?

    func deriveChild(i: ZcashChildIndex) throws -> ZcashExtendedFullViewingKey

    func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress?

    func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func deriveInternal() -> ZcashExtendedFullViewingKey

    func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey
}

public class ZcashExtendedFullViewingKey: ZcashExtendedFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashExtendedFullViewingKey {
        return try ZcashExtendedFullViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedFullViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashExtendedFullViewingKey {
        return try ZcashExtendedFullViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedFullViewingKey_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(input), $0
                )
            })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_encode(self.pointer,
                                                                 FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_address(self.pointer,
                                                                  FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func deriveChild(i: ZcashChildIndex) throws -> ZcashExtendedFullViewingKey {
        return try FfiConverterTypeZcashExtendedFullViewingKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedFullViewingKey_derive_child(self.pointer,
                                                                   FfiConverterTypeZcashChildIndex.lower(i), $0)
            }
        )
    }

    public func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress? {
        return try! FfiConverterOptionTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_find_address(self.pointer,
                                                                       FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_default_address(self.pointer, $0)
                }
        )
    }

    public func deriveInternal() -> ZcashExtendedFullViewingKey {
        return try! FfiConverterTypeZcashExtendedFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_derive_internal(self.pointer, $0)
                }
        )
    }

    public func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey {
        return try! FfiConverterTypeZcashDiversifiableFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtendedFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtendedFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtendedFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtendedFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedFullViewingKey {
        return ZcashExtendedFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtendedFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtendedFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedFullViewingKey {
    return try FfiConverterTypeZcashExtendedFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashExtendedFullViewingKey_lower(_ value: ZcashExtendedFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtendedFullViewingKey.lower(value)
}

public protocol ZcashExtendedPrivKeyProtocol {
    func toBytes() -> [UInt8]

    func derivePrivateKey(keyIndex: ZcashKeyIndex) throws -> ZcashExtendedPrivKey
}

public class ZcashExtendedPrivKey: ZcashExtendedPrivKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExtendedPrivKey_object_free(pointer, $0) }
    }

    public static func random() throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedPrivKey_random($0)
            })
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedPrivKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public static func randomWithSeedSize(seedSize: ZcashKeySeed) throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedPrivKey_random_with_seed_size(
                    FfiConverterTypeZcashKeySeed.lower(seedSize), $0
                )
            })
    }

    public static func withSeed(data: [UInt8]) throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedPrivKey_with_seed(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedPrivKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func derivePrivateKey(keyIndex: ZcashKeyIndex) throws -> ZcashExtendedPrivKey {
        return try FfiConverterTypeZcashExtendedPrivKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedPrivKey_derive_private_key(self.pointer,
                                                                  FfiConverterTypeZcashKeyIndex.lower(keyIndex), $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashExtendedPrivKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtendedPrivKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtendedPrivKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtendedPrivKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedPrivKey {
        return ZcashExtendedPrivKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtendedPrivKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtendedPrivKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedPrivKey {
    return try FfiConverterTypeZcashExtendedPrivKey.lift(pointer)
}

public func FfiConverterTypeZcashExtendedPrivKey_lower(_ value: ZcashExtendedPrivKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtendedPrivKey.lower(value)
}

public protocol ZcashExtendedSpendingKeyProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func toBytes() -> [UInt8]

    func deriveChild(index: ZcashChildIndex) -> ZcashExtendedSpendingKey

    func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func deriveInternal() -> ZcashExtendedSpendingKey

    func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey
}

public class ZcashExtendedSpendingKey: ZcashExtendedSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExtendedSpendingKey_object_free(pointer, $0) }
    }

    public static func master(data: [UInt8]) -> ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashExtendedSpendingKey_master(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashExtendedSpendingKey {
        return try ZcashExtendedSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedSpendingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func fromPath(master: ZcashExtendedSpendingKey, path: [ZcashChildIndex]) -> ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashExtendedSpendingKey_from_path(
                    FfiConverterTypeZcashExtendedSpendingKey.lower(master),
                    FfiConverterSequenceTypeZcashChildIndex.lower(path), $0
                )
            })
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashExtendedSpendingKey {
        return try ZcashExtendedSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtendedSpendingKey_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(input), $0
                )
            })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedSpendingKey_encode(self.pointer,
                                                              FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedSpendingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func deriveChild(index: ZcashChildIndex) -> ZcashExtendedSpendingKey {
        return try! FfiConverterTypeZcashExtendedSpendingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedSpendingKey_derive_child(self.pointer,
                                                                    FfiConverterTypeZcashChildIndex.lower(index), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedSpendingKey_default_address(self.pointer, $0)
                }
        )
    }

    public func deriveInternal() -> ZcashExtendedSpendingKey {
        return try! FfiConverterTypeZcashExtendedSpendingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedSpendingKey_derive_internal(self.pointer, $0)
                }
        )
    }

    public func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey {
        return try! FfiConverterTypeZcashDiversifiableFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtendedSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtendedSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtendedSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtendedSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtendedSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtendedSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedSpendingKey {
    return try FfiConverterTypeZcashExtendedSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashExtendedSpendingKey_lower(_ value: ZcashExtendedSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtendedSpendingKey.lower(value)
}

public protocol ZcashExternalIvkProtocol {
    func deriveAddress(childIndex: UInt32) throws -> ZcashTransparentAddress

    func defaultAddress() -> ZcashTransparentAddressAndIndex

    func toBytes() -> [UInt8]
}

public class ZcashExternalIvk: ZcashExternalIvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExternalIvk_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashExternalIvk {
        return try ZcashExternalIvk(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExternalIvk_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func deriveAddress(childIndex: UInt32) throws -> ZcashTransparentAddress {
        return try FfiConverterTypeZcashTransparentAddress.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExternalIvk_derive_address(self.pointer,
                                                          FfiConverterUInt32.lower(childIndex), $0)
            }
        )
    }

    public func defaultAddress() -> ZcashTransparentAddressAndIndex {
        return try! FfiConverterTypeZcashTransparentAddressAndIndex.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExternalIvk_default_address(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExternalIvk_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExternalIvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExternalIvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExternalIvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExternalIvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalIvk {
        return ZcashExternalIvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExternalIvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExternalIvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalIvk {
    return try FfiConverterTypeZcashExternalIvk.lift(pointer)
}

public func FfiConverterTypeZcashExternalIvk_lower(_ value: ZcashExternalIvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExternalIvk.lower(value)
}

public protocol ZcashExternalOvkProtocol {
    func asBytes() -> [UInt8]
}

public class ZcashExternalOvk: ZcashExternalOvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExternalOvk_object_free(pointer, $0) }
    }

    public func asBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExternalOvk_as_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExternalOvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExternalOvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExternalOvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExternalOvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalOvk {
        return ZcashExternalOvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExternalOvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExternalOvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalOvk {
    return try FfiConverterTypeZcashExternalOvk.lift(pointer)
}

public func FfiConverterTypeZcashExternalOvk_lower(_ value: ZcashExternalOvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExternalOvk.lower(value)
}

public protocol ZcashExtractedNoteCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashExtractedNoteCommitment: ZcashExtractedNoteCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashExtractedNoteCommitment {
        return try ZcashExtractedNoteCommitment(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashExtractedNoteCommitment_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashExtractedNoteCommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtractedNoteCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtractedNoteCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtractedNoteCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtractedNoteCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtractedNoteCommitment {
        return ZcashExtractedNoteCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtractedNoteCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtractedNoteCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtractedNoteCommitment {
    return try FfiConverterTypeZcashExtractedNoteCommitment.lift(pointer)
}

public func FfiConverterTypeZcashExtractedNoteCommitment_lower(_ value: ZcashExtractedNoteCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtractedNoteCommitment.lower(value)
}

public protocol ZcashFixedFeeRuleProtocol {
    func fixedFee() -> ZcashAmount
}

public class ZcashFixedFeeRule: ZcashFixedFeeRuleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashFixedFeeRule_object_free(pointer, $0) }
    }

    public static func nonStandard(fixedFee: ZcashAmount) -> ZcashFixedFeeRule {
        return ZcashFixedFeeRule(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashFixedFeeRule_non_standard(
                    FfiConverterTypeZcashAmount.lower(fixedFee), $0
                )
            })
    }

    public static func standard() -> ZcashFixedFeeRule {
        return ZcashFixedFeeRule(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashFixedFeeRule_standard($0)
            })
    }

    public func fixedFee() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    zcash_e53_ZcashFixedFeeRule_fixed_fee(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashFixedFeeRule: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashFixedFeeRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFixedFeeRule {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashFixedFeeRule, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFixedFeeRule {
        return ZcashFixedFeeRule(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashFixedFeeRule) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashFixedFeeRule_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFixedFeeRule {
    return try FfiConverterTypeZcashFixedFeeRule.lift(pointer)
}

public func FfiConverterTypeZcashFixedFeeRule_lower(_ value: ZcashFixedFeeRule) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashFixedFeeRule.lower(value)
}

public protocol ZcashFullViewingKeyProtocol {
    func toBytes() -> [UInt8]

    func vk() -> ZcashViewingKey

    func ovk() -> ZcashOutgoingViewingKey
}

public class ZcashFullViewingKey: ZcashFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashFullViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashFullViewingKey {
        return try ZcashFullViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashFullViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public static func fromExpandedSpendingKey(expsk: ZcashExpandedSpendingKey) -> ZcashFullViewingKey {
        return ZcashFullViewingKey(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashFullViewingKey_from_expanded_spending_key(
                    FfiConverterTypeZcashExpandedSpendingKey.lower(expsk), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashFullViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func vk() -> ZcashViewingKey {
        return try! FfiConverterTypeZcashViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashFullViewingKey_vk(self.pointer, $0)
                }
        )
    }

    public func ovk() -> ZcashOutgoingViewingKey {
        return try! FfiConverterTypeZcashOutgoingViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashFullViewingKey_ovk(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFullViewingKey {
        return ZcashFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFullViewingKey {
    return try FfiConverterTypeZcashFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashFullViewingKey_lower(_ value: ZcashFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashFullViewingKey.lower(value)
}

public protocol ZcashIncrementalWitnessProtocol {
    func append(node: ZcashSaplingNode) throws

    func path() -> ZcashSaplingMerklePath?
}

public class ZcashIncrementalWitness: ZcashIncrementalWitnessProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashIncrementalWitness_object_free(pointer, $0) }
    }

    public static func fromTree(tree: ZcashCommitmentTree) -> ZcashIncrementalWitness {
        return ZcashIncrementalWitness(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashIncrementalWitness_from_tree(
                    FfiConverterTypeZcashCommitmentTree.lower(tree), $0
                )
            })
    }

    public func append(node: ZcashSaplingNode) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashIncrementalWitness_append(self.pointer,
                                                         FfiConverterTypeZcashSaplingNode.lower(node), $0)
            }
    }

    public func path() -> ZcashSaplingMerklePath? {
        return try! FfiConverterOptionTypeZcashSaplingMerklePath.lift(
            try!
                rustCall {
                    zcash_e53_ZcashIncrementalWitness_path(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashIncrementalWitness: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashIncrementalWitness

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashIncrementalWitness {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashIncrementalWitness, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashIncrementalWitness {
        return ZcashIncrementalWitness(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashIncrementalWitness) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashIncrementalWitness_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashIncrementalWitness {
    return try FfiConverterTypeZcashIncrementalWitness.lift(pointer)
}

public func FfiConverterTypeZcashIncrementalWitness_lower(_ value: ZcashIncrementalWitness) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashIncrementalWitness.lower(value)
}

public protocol ZcashInternalIvkProtocol {
    func defaultAddress() -> ZcashTransparentAddressAndIndex

    func toBytes() -> [UInt8]
}

public class ZcashInternalIvk: ZcashInternalIvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashInternalIvk_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashInternalIvk {
        return try ZcashInternalIvk(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashInternalIvk_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func defaultAddress() -> ZcashTransparentAddressAndIndex {
        return try! FfiConverterTypeZcashTransparentAddressAndIndex.lift(
            try!
                rustCall {
                    zcash_e53_ZcashInternalIvk_default_address(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashInternalIvk_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashInternalIvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashInternalIvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashInternalIvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashInternalIvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalIvk {
        return ZcashInternalIvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashInternalIvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashInternalIvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalIvk {
    return try FfiConverterTypeZcashInternalIvk.lift(pointer)
}

public func FfiConverterTypeZcashInternalIvk_lower(_ value: ZcashInternalIvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashInternalIvk.lower(value)
}

public protocol ZcashInternalOvkProtocol {
    func asBytes() -> [UInt8]
}

public class ZcashInternalOvk: ZcashInternalOvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashInternalOvk_object_free(pointer, $0) }
    }

    public func asBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashInternalOvk_as_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashInternalOvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashInternalOvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashInternalOvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashInternalOvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalOvk {
        return ZcashInternalOvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashInternalOvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashInternalOvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalOvk {
    return try FfiConverterTypeZcashInternalOvk.lift(pointer)
}

public func FfiConverterTypeZcashInternalOvk_lower(_ value: ZcashInternalOvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashInternalOvk.lower(value)
}

public protocol ZcashJubjubFrProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashJubjubFr: ZcashJubjubFrProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashJubjubFr_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashJubjubFr {
        return try ZcashJubjubFr(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashJubjubFr_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashJubjubFr_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashJubjubFr: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashJubjubFr

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashJubjubFr {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashJubjubFr, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashJubjubFr {
        return ZcashJubjubFr(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashJubjubFr) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashJubjubFr_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashJubjubFr {
    return try FfiConverterTypeZcashJubjubFr.lift(pointer)
}

public func FfiConverterTypeZcashJubjubFr_lower(_ value: ZcashJubjubFr) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashJubjubFr.lower(value)
}

public protocol ZcashKeyIndexProtocol {
    func rawIndex() -> UInt32

    func normalizeIndex() -> UInt32

    func isValid() -> Bool
}

public class ZcashKeyIndex: ZcashKeyIndexProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashKeyIndex_object_free(pointer, $0) }
    }

    public static func fromU32(i: UInt32) throws -> ZcashKeyIndex {
        return try ZcashKeyIndex(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashKeyIndex_from_u32(
                    FfiConverterUInt32.lower(i), $0
                )
            })
    }

    public static func hardenedFromNormalizeIndex(i: UInt32) throws -> ZcashKeyIndex {
        return try ZcashKeyIndex(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashKeyIndex_hardened_from_normalize_index(
                    FfiConverterUInt32.lower(i), $0
                )
            })
    }

    public static func fromIndex(i: UInt32) throws -> ZcashKeyIndex {
        return try ZcashKeyIndex(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashKeyIndex_from_index(
                    FfiConverterUInt32.lower(i), $0
                )
            })
    }

    public func rawIndex() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_ZcashKeyIndex_raw_index(self.pointer, $0)
                }
        )
    }

    public func normalizeIndex() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_ZcashKeyIndex_normalize_index(self.pointer, $0)
                }
        )
    }

    public func isValid() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashKeyIndex_is_valid(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashKeyIndex: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashKeyIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashKeyIndex {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashKeyIndex, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashKeyIndex {
        return ZcashKeyIndex(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashKeyIndex) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashKeyIndex_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashKeyIndex {
    return try FfiConverterTypeZcashKeyIndex.lift(pointer)
}

public func FfiConverterTypeZcashKeyIndex_lower(_ value: ZcashKeyIndex) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashKeyIndex.lower(value)
}

public protocol ZcashLocalTxProverProtocol {}

public class ZcashLocalTxProver: ZcashLocalTxProverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(spendPath: String, outputPath: String) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashLocalTxProver_new(
                    FfiConverterString.lower(spendPath),
                    FfiConverterString.lower(outputPath), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashLocalTxProver_object_free(pointer, $0) }
    }

    public static func fromBytes(spendParamBytes: [UInt8], outputParamBytes: [UInt8]) -> ZcashLocalTxProver {
        return ZcashLocalTxProver(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashLocalTxProver_from_bytes(
                    FfiConverterSequenceUInt8.lower(spendParamBytes),
                    FfiConverterSequenceUInt8.lower(outputParamBytes), $0
                )
            })
    }

    public static func withDefaultLocation() throws -> ZcashLocalTxProver {
        return try ZcashLocalTxProver(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashLocalTxProver_with_default_location($0)
            })
    }
}

public struct FfiConverterTypeZcashLocalTxProver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashLocalTxProver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashLocalTxProver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashLocalTxProver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashLocalTxProver {
        return ZcashLocalTxProver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashLocalTxProver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashLocalTxProver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashLocalTxProver {
    return try FfiConverterTypeZcashLocalTxProver.lift(pointer)
}

public func FfiConverterTypeZcashLocalTxProver_lower(_ value: ZcashLocalTxProver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashLocalTxProver.lower(value)
}

public protocol ZcashMemoBytesProtocol {
    func data() -> [UInt8]
}

public class ZcashMemoBytes: ZcashMemoBytesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashMemoBytes_new(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashMemoBytes_object_free(pointer, $0) }
    }

    public static func empty() -> ZcashMemoBytes {
        return ZcashMemoBytes(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashMemoBytes_empty($0)
            })
    }

    public func data() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashMemoBytes_data(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashMemoBytes: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashMemoBytes

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashMemoBytes {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashMemoBytes, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashMemoBytes {
        return ZcashMemoBytes(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashMemoBytes) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashMemoBytes_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashMemoBytes {
    return try FfiConverterTypeZcashMemoBytes.lift(pointer)
}

public func FfiConverterTypeZcashMemoBytes_lower(_ value: ZcashMemoBytes) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashMemoBytes.lower(value)
}

public protocol ZcashNullifierDerivingKeyProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashNullifierDerivingKey: ZcashNullifierDerivingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashNullifierDerivingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashNullifierDerivingKey {
        return try ZcashNullifierDerivingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashNullifierDerivingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashNullifierDerivingKey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashNullifierDerivingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashNullifierDerivingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashNullifierDerivingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashNullifierDerivingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNullifierDerivingKey {
        return ZcashNullifierDerivingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashNullifierDerivingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashNullifierDerivingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNullifierDerivingKey {
    return try FfiConverterTypeZcashNullifierDerivingKey.lift(pointer)
}

public func FfiConverterTypeZcashNullifierDerivingKey_lower(_ value: ZcashNullifierDerivingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashNullifierDerivingKey.lower(value)
}

public protocol ZcashOrchardActionProtocol {
    func nullifier() -> ZcashOrchardNullifier

    func cmx() -> ZcashExtractedNoteCommitment

    func encryptedNote() -> ZcashOrchardTransmittedNoteCiphertext

    func cvNet() -> ZcashOrchardValueCommitment
}

public class ZcashOrchardAction: ZcashOrchardActionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardAction_object_free(pointer, $0) }
    }

    public func nullifier() -> ZcashOrchardNullifier {
        return try! FfiConverterTypeZcashOrchardNullifier.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardAction_nullifier(self.pointer, $0)
                }
        )
    }

    public func cmx() -> ZcashExtractedNoteCommitment {
        return try! FfiConverterTypeZcashExtractedNoteCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardAction_cmx(self.pointer, $0)
                }
        )
    }

    public func encryptedNote() -> ZcashOrchardTransmittedNoteCiphertext {
        return try! FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardAction_encrypted_note(self.pointer, $0)
                }
        )
    }

    public func cvNet() -> ZcashOrchardValueCommitment {
        return try! FfiConverterTypeZcashOrchardValueCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardAction_cv_net(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardAction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardAction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardAction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAction {
        return ZcashOrchardAction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardAction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardAction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAction {
    return try FfiConverterTypeZcashOrchardAction.lift(pointer)
}

public func FfiConverterTypeZcashOrchardAction_lower(_ value: ZcashOrchardAction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardAction.lower(value)
}

public protocol ZcashOrchardAddressProtocol {
    func diversifier() -> ZcashOrchardDiversifier

    func toRawAddressBytes() -> [UInt8]
}

public class ZcashOrchardAddress: ZcashOrchardAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardAddress_object_free(pointer, $0) }
    }

    public static func fromRawAddressBytes(bytes: [UInt8]) throws -> ZcashOrchardAddress {
        return try ZcashOrchardAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardAddress_from_raw_address_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func diversifier() -> ZcashOrchardDiversifier {
        return try! FfiConverterTypeZcashOrchardDiversifier.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardAddress_diversifier(self.pointer, $0)
                }
        )
    }

    public func toRawAddressBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardAddress_to_raw_address_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAddress {
        return ZcashOrchardAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAddress {
    return try FfiConverterTypeZcashOrchardAddress.lift(pointer)
}

public func FfiConverterTypeZcashOrchardAddress_lower(_ value: ZcashOrchardAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardAddress.lower(value)
}

public protocol ZcashOrchardBundleProtocol {
    func actions() -> [ZcashOrchardAction]

    func flags() -> ZcashOrchardFlags

    func valueBalance() -> ZcashAmount

    func anchor() -> ZcashAnchor

    func verifyProof(key: ZcashVerifyingKey) throws

    func decryptOutputWithKey(actionIdx: UInt64, ivk: ZcashOrchardIncomingViewingKey) throws -> ZcashOrchardDecryptOutput

    func decryptOutputWithKeys(ivks: [ZcashOrchardIncomingViewingKey]) -> [ZcashOrchardDecryptOutputForIncomingKeys]

    func recoverOutputWithOvk(actionIdx: UInt64, ovk: ZcashOrchardOutgoingViewingKey) throws -> ZcashOrchardDecryptOutput

    func recoverOutputsWithOvks(ovks: [ZcashOrchardOutgoingViewingKey]) -> [ZcashOrchardDecryptOutputForOutgoingKeys]
}

public class ZcashOrchardBundle: ZcashOrchardBundleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardBundle_object_free(pointer, $0) }
    }

    public func actions() -> [ZcashOrchardAction] {
        return try! FfiConverterSequenceTypeZcashOrchardAction.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardBundle_actions(self.pointer, $0)
                }
        )
    }

    public func flags() -> ZcashOrchardFlags {
        return try! FfiConverterTypeZcashOrchardFlags.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardBundle_flags(self.pointer, $0)
                }
        )
    }

    public func valueBalance() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardBundle_value_balance(self.pointer, $0)
                }
        )
    }

    public func anchor() -> ZcashAnchor {
        return try! FfiConverterTypeZcashAnchor.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardBundle_anchor(self.pointer, $0)
                }
        )
    }

    public func verifyProof(key: ZcashVerifyingKey) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardBundle_verify_proof(self.pointer,
                                                          FfiConverterTypeZcashVerifyingKey.lower(key), $0)
            }
    }

    public func decryptOutputWithKey(actionIdx: UInt64, ivk: ZcashOrchardIncomingViewingKey) throws -> ZcashOrchardDecryptOutput {
        return try FfiConverterTypeZcashOrchardDecryptOutput.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardBundle_decrypt_output_with_key(self.pointer,
                                                                     FfiConverterUInt64.lower(actionIdx),
                                                                     FfiConverterTypeZcashOrchardIncomingViewingKey.lower(ivk), $0)
            }
        )
    }

    public func decryptOutputWithKeys(ivks: [ZcashOrchardIncomingViewingKey]) -> [ZcashOrchardDecryptOutputForIncomingKeys] {
        return try! FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys(self.pointer,
                                                                          FfiConverterSequenceTypeZcashOrchardIncomingViewingKey.lower(ivks), $0)
                }
        )
    }

    public func recoverOutputWithOvk(actionIdx: UInt64, ovk: ZcashOrchardOutgoingViewingKey) throws -> ZcashOrchardDecryptOutput {
        return try FfiConverterTypeZcashOrchardDecryptOutput.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardBundle_recover_output_with_ovk(self.pointer,
                                                                     FfiConverterUInt64.lower(actionIdx),
                                                                     FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(ovk), $0)
            }
        )
    }

    public func recoverOutputsWithOvks(ovks: [ZcashOrchardOutgoingViewingKey]) -> [ZcashOrchardDecryptOutputForOutgoingKeys] {
        return try! FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks(self.pointer,
                                                                           FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey.lower(ovks), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardBundle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardBundle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardBundle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardBundle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardBundle {
        return ZcashOrchardBundle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardBundle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardBundle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardBundle {
    return try FfiConverterTypeZcashOrchardBundle.lift(pointer)
}

public func FfiConverterTypeZcashOrchardBundle_lower(_ value: ZcashOrchardBundle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardBundle.lower(value)
}

public protocol ZcashOrchardDiversifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardDiversifier: ZcashOrchardDiversifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardDiversifier_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardDiversifier {
        return try ZcashOrchardDiversifier(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardDiversifier_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardDiversifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardDiversifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardDiversifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDiversifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardDiversifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifier {
        return ZcashOrchardDiversifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardDiversifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardDiversifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifier {
    return try FfiConverterTypeZcashOrchardDiversifier.lift(pointer)
}

public func FfiConverterTypeZcashOrchardDiversifier_lower(_ value: ZcashOrchardDiversifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardDiversifier.lower(value)
}

public protocol ZcashOrchardDiversifierIndexProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardDiversifierIndex: ZcashOrchardDiversifierIndexProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free(pointer, $0) }
    }

    public static func fromBytes(b: [UInt8]) throws -> ZcashOrchardDiversifierIndex {
        return try ZcashOrchardDiversifierIndex(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardDiversifierIndex_from_bytes(
                    FfiConverterSequenceUInt8.lower(b), $0
                )
            })
    }

    public static func fromU32(i: UInt32) -> ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashOrchardDiversifierIndex_from_u32(
                    FfiConverterUInt32.lower(i), $0
                )
            })
    }

    public static func fromU64(i: UInt64) -> ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashOrchardDiversifierIndex_from_u64(
                    FfiConverterUInt64.lower(i), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardDiversifierIndex_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardDiversifierIndex: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardDiversifierIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDiversifierIndex {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardDiversifierIndex, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardDiversifierIndex) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardDiversifierIndex_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifierIndex {
    return try FfiConverterTypeZcashOrchardDiversifierIndex.lift(pointer)
}

public func FfiConverterTypeZcashOrchardDiversifierIndex_lower(_ value: ZcashOrchardDiversifierIndex) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardDiversifierIndex.lower(value)
}

public protocol ZcashOrchardFlagsProtocol {
    func spendsEnabled() -> Bool

    func outputsEnabled() -> Bool

    func toByte() -> UInt8
}

public class ZcashOrchardFlags: ZcashOrchardFlagsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardFlags_object_free(pointer, $0) }
    }

    public static func fromParts(spendsEnabled: Bool, outputsEnabled: Bool) -> ZcashOrchardFlags {
        return ZcashOrchardFlags(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashOrchardFlags_from_parts(
                    FfiConverterBool.lower(spendsEnabled),
                    FfiConverterBool.lower(outputsEnabled), $0
                )
            })
    }

    public static func fromByte(v: UInt8) throws -> ZcashOrchardFlags {
        return try ZcashOrchardFlags(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardFlags_from_byte(
                    FfiConverterUInt8.lower(v), $0
                )
            })
    }

    public func spendsEnabled() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFlags_spends_enabled(self.pointer, $0)
                }
        )
    }

    public func outputsEnabled() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFlags_outputs_enabled(self.pointer, $0)
                }
        )
    }

    public func toByte() -> UInt8 {
        return try! FfiConverterUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFlags_to_byte(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardFlags: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardFlags

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardFlags {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardFlags, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFlags {
        return ZcashOrchardFlags(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardFlags) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardFlags_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFlags {
    return try FfiConverterTypeZcashOrchardFlags.lift(pointer)
}

public func FfiConverterTypeZcashOrchardFlags_lower(_ value: ZcashOrchardFlags) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardFlags.lower(value)
}

public protocol ZcashOrchardFullViewingKeyProtocol {
    func addressAt(j: ZcashOrchardDiversifierIndex, scope: ZcashOrchardScope) -> ZcashOrchardAddress

    func address(d: ZcashOrchardDiversifier, scope: ZcashOrchardScope) -> ZcashOrchardAddress

    func scopeForAddress(address: ZcashOrchardAddress) -> ZcashOrchardScope?

    func toBytes() -> [UInt8]

    func toIvk(scope: ZcashOrchardScope) -> ZcashOrchardIncomingViewingKey

    func toOvk(scope: ZcashOrchardScope) -> ZcashOrchardOutgoingViewingKey
}

public class ZcashOrchardFullViewingKey: ZcashOrchardFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardFullViewingKey {
        return try ZcashOrchardFullViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardFullViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func addressAt(j: ZcashOrchardDiversifierIndex, scope: ZcashOrchardScope) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFullViewingKey_address_at(self.pointer,
                                                                    FfiConverterTypeZcashOrchardDiversifierIndex.lower(j),
                                                                    FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }

    public func address(d: ZcashOrchardDiversifier, scope: ZcashOrchardScope) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFullViewingKey_address(self.pointer,
                                                                 FfiConverterTypeZcashOrchardDiversifier.lower(d),
                                                                 FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }

    public func scopeForAddress(address: ZcashOrchardAddress) -> ZcashOrchardScope? {
        return try! FfiConverterOptionTypeZcashOrchardScope.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFullViewingKey_scope_for_address(self.pointer,
                                                                           FfiConverterTypeZcashOrchardAddress.lower(address), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFullViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toIvk(scope: ZcashOrchardScope) -> ZcashOrchardIncomingViewingKey {
        return try! FfiConverterTypeZcashOrchardIncomingViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFullViewingKey_to_ivk(self.pointer,
                                                                FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }

    public func toOvk(scope: ZcashOrchardScope) -> ZcashOrchardOutgoingViewingKey {
        return try! FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardFullViewingKey_to_ovk(self.pointer,
                                                                FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFullViewingKey {
        return ZcashOrchardFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFullViewingKey {
    return try FfiConverterTypeZcashOrchardFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardFullViewingKey_lower(_ value: ZcashOrchardFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardFullViewingKey.lower(value)
}

public protocol ZcashOrchardIncomingViewingKeyProtocol {
    func toBytes() -> [UInt8]

    func diversifierIndex(addr: ZcashOrchardAddress) -> ZcashOrchardDiversifierIndex?

    func addressAt(j: ZcashOrchardDiversifierIndex) -> ZcashOrchardAddress

    func address(diversifier: ZcashOrchardDiversifier) -> ZcashOrchardAddress
}

public class ZcashOrchardIncomingViewingKey: ZcashOrchardIncomingViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardIncomingViewingKey {
        return try ZcashOrchardIncomingViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func diversifierIndex(addr: ZcashOrchardAddress) -> ZcashOrchardDiversifierIndex? {
        return try! FfiConverterOptionTypeZcashOrchardDiversifierIndex.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index(self.pointer,
                                                                               FfiConverterTypeZcashOrchardAddress.lower(addr), $0)
                }
        )
    }

    public func addressAt(j: ZcashOrchardDiversifierIndex) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardIncomingViewingKey_address_at(self.pointer,
                                                                        FfiConverterTypeZcashOrchardDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func address(diversifier: ZcashOrchardDiversifier) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardIncomingViewingKey_address(self.pointer,
                                                                     FfiConverterTypeZcashOrchardDiversifier.lower(diversifier), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardIncomingViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardIncomingViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardIncomingViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardIncomingViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardIncomingViewingKey {
        return ZcashOrchardIncomingViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardIncomingViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardIncomingViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardIncomingViewingKey {
    return try FfiConverterTypeZcashOrchardIncomingViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardIncomingViewingKey_lower(_ value: ZcashOrchardIncomingViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardIncomingViewingKey.lower(value)
}

public protocol ZcashOrchardMerkleHashProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardMerkleHash: ZcashOrchardMerkleHashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardMerkleHash_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashOrchardMerkleHash {
        return try ZcashOrchardMerkleHash(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardMerkleHash_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func fromCmx(cmx: ZcashExtractedNoteCommitment) -> ZcashOrchardMerkleHash {
        return ZcashOrchardMerkleHash(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashOrchardMerkleHash_from_cmx(
                    FfiConverterTypeZcashExtractedNoteCommitment.lower(cmx), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardMerkleHash_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardMerkleHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardMerkleHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardMerkleHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardMerkleHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerkleHash {
        return ZcashOrchardMerkleHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardMerkleHash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardMerkleHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerkleHash {
    return try FfiConverterTypeZcashOrchardMerkleHash.lift(pointer)
}

public func FfiConverterTypeZcashOrchardMerkleHash_lower(_ value: ZcashOrchardMerkleHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardMerkleHash.lower(value)
}

public protocol ZcashOrchardMerklePathProtocol {
    func root(cmx: ZcashExtractedNoteCommitment) -> ZcashAnchor
}

public class ZcashOrchardMerklePath: ZcashOrchardMerklePathProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardMerklePath_object_free(pointer, $0) }
    }

    public static func fromParts(position: UInt32, authPath: [ZcashOrchardMerkleHash]) throws -> ZcashOrchardMerklePath {
        return try ZcashOrchardMerklePath(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardMerklePath_from_parts(
                    FfiConverterUInt32.lower(position),
                    FfiConverterSequenceTypeZcashOrchardMerkleHash.lower(authPath), $0
                )
            })
    }

    public func root(cmx: ZcashExtractedNoteCommitment) -> ZcashAnchor {
        return try! FfiConverterTypeZcashAnchor.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardMerklePath_root(self.pointer,
                                                          FfiConverterTypeZcashExtractedNoteCommitment.lower(cmx), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardMerklePath: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardMerklePath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardMerklePath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardMerklePath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerklePath {
        return ZcashOrchardMerklePath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardMerklePath) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardMerklePath_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerklePath {
    return try FfiConverterTypeZcashOrchardMerklePath.lift(pointer)
}

public func FfiConverterTypeZcashOrchardMerklePath_lower(_ value: ZcashOrchardMerklePath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardMerklePath.lower(value)
}

public protocol ZcashOrchardNoteProtocol {
    func recipient() -> ZcashOrchardAddress

    func value() -> ZcashOrchardNoteValue

    func commitment() -> ZcashOrchardNoteCommitment
}

public class ZcashOrchardNote: ZcashOrchardNoteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardNote_object_free(pointer, $0) }
    }

    public static func fromParts(recipient: ZcashOrchardAddress, value: ZcashOrchardNoteValue, rho: ZcashOrchardNullifier, rseed: ZcashOrchardRandomSeed) throws -> ZcashOrchardNote {
        return try ZcashOrchardNote(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardNote_from_parts(
                    FfiConverterTypeZcashOrchardAddress.lower(recipient),
                    FfiConverterTypeZcashOrchardNoteValue.lower(value),
                    FfiConverterTypeZcashOrchardNullifier.lower(rho),
                    FfiConverterTypeZcashOrchardRandomSeed.lower(rseed), $0
                )
            })
    }

    public func recipient() -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardNote_recipient(self.pointer, $0)
                }
        )
    }

    public func value() -> ZcashOrchardNoteValue {
        return try! FfiConverterTypeZcashOrchardNoteValue.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardNote_value(self.pointer, $0)
                }
        )
    }

    public func commitment() -> ZcashOrchardNoteCommitment {
        return try! FfiConverterTypeZcashOrchardNoteCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardNote_commitment(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNote: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNote

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNote {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNote, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNote {
        return ZcashOrchardNote(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNote) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNote_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNote {
    return try FfiConverterTypeZcashOrchardNote.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNote_lower(_ value: ZcashOrchardNote) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNote.lower(value)
}

public protocol ZcashOrchardNoteCommitmentProtocol {
    func toExtractedNoteCommitment() -> ZcashExtractedNoteCommitment
}

public class ZcashOrchardNoteCommitment: ZcashOrchardNoteCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free(pointer, $0) }
    }

    public func toExtractedNoteCommitment() -> ZcashExtractedNoteCommitment {
        return try! FfiConverterTypeZcashExtractedNoteCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNoteCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNoteCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNoteCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNoteCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteCommitment {
        return ZcashOrchardNoteCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNoteCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNoteCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteCommitment {
    return try FfiConverterTypeZcashOrchardNoteCommitment.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNoteCommitment_lower(_ value: ZcashOrchardNoteCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNoteCommitment.lower(value)
}

public protocol ZcashOrchardNoteValueProtocol {
    func value() -> UInt64
}

public class ZcashOrchardNoteValue: ZcashOrchardNoteValueProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardNoteValue_object_free(pointer, $0) }
    }

    public static func fromRaw(value: UInt64) -> ZcashOrchardNoteValue {
        return ZcashOrchardNoteValue(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashOrchardNoteValue_from_raw(
                    FfiConverterUInt64.lower(value), $0
                )
            })
    }

    public func value() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardNoteValue_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNoteValue: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNoteValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNoteValue {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNoteValue, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteValue {
        return ZcashOrchardNoteValue(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNoteValue) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNoteValue_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteValue {
    return try FfiConverterTypeZcashOrchardNoteValue.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNoteValue_lower(_ value: ZcashOrchardNoteValue) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNoteValue.lower(value)
}

public protocol ZcashOrchardNullifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardNullifier: ZcashOrchardNullifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardNullifier_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashOrchardNullifier {
        return try ZcashOrchardNullifier(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardNullifier_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardNullifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNullifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNullifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNullifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNullifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNullifier {
        return ZcashOrchardNullifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNullifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNullifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNullifier {
    return try FfiConverterTypeZcashOrchardNullifier.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNullifier_lower(_ value: ZcashOrchardNullifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNullifier.lower(value)
}

public protocol ZcashOrchardOutgoingViewingKeyProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardOutgoingViewingKey: ZcashOrchardOutgoingViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardOutgoingViewingKey {
        return try ZcashOrchardOutgoingViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardOutgoingViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardOutgoingViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardOutgoingViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardOutgoingViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardOutgoingViewingKey {
        return ZcashOrchardOutgoingViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardOutgoingViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardOutgoingViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardOutgoingViewingKey {
    return try FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardOutgoingViewingKey_lower(_ value: ZcashOrchardOutgoingViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(value)
}

public protocol ZcashOrchardRandomSeedProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardRandomSeed: ZcashOrchardRandomSeedProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardRandomSeed_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8], rho: ZcashOrchardNullifier) throws -> ZcashOrchardRandomSeed {
        return try ZcashOrchardRandomSeed(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardRandomSeed_from_bytes(
                    FfiConverterSequenceUInt8.lower(data),
                    FfiConverterTypeZcashOrchardNullifier.lower(rho), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardRandomSeed_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardRandomSeed: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardRandomSeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardRandomSeed {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardRandomSeed, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardRandomSeed {
        return ZcashOrchardRandomSeed(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardRandomSeed) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardRandomSeed_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardRandomSeed {
    return try FfiConverterTypeZcashOrchardRandomSeed.lift(pointer)
}

public func FfiConverterTypeZcashOrchardRandomSeed_lower(_ value: ZcashOrchardRandomSeed) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardRandomSeed.lower(value)
}

public protocol ZcashOrchardSpendingKeyProtocol {
    func toBytes() -> [UInt8]

    func toFvk() -> ZcashOrchardFullViewingKey
}

public class ZcashOrchardSpendingKey: ZcashOrchardSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardSpendingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashOrchardSpendingKey {
        return try ZcashOrchardSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardSpendingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func fromZip32Seed(seed: [UInt8], coinType: UInt32, account: UInt32) throws -> ZcashOrchardSpendingKey {
        return try ZcashOrchardSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed(
                    FfiConverterSequenceUInt8.lower(seed),
                    FfiConverterUInt32.lower(coinType),
                    FfiConverterUInt32.lower(account), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardSpendingKey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toFvk() -> ZcashOrchardFullViewingKey {
        return try! FfiConverterTypeZcashOrchardFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardSpendingKey_to_fvk(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardSpendingKey {
        return ZcashOrchardSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardSpendingKey {
    return try FfiConverterTypeZcashOrchardSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardSpendingKey_lower(_ value: ZcashOrchardSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardSpendingKey.lower(value)
}

public protocol ZcashOrchardTransactionBuilderProtocol {
    func addSpend(fvk: ZcashOrchardFullViewingKey, note: ZcashOrchardNote, merklePath: ZcashOrchardMerklePath)

    func addRecipient(ovk: ZcashOrchardOutgoingViewingKey?, recipient: ZcashOrchardAddress, value: UInt64, memo: [UInt8]?) throws

    func build(keys: [ZcashOrchardSpendingKey], sighash: [UInt8]) throws -> ZcashTransaction
}

public class ZcashOrchardTransactionBuilder: ZcashOrchardTransactionBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(parameters: ZcashConsensusParameters, targetHeight: ZcashBlockHeight, expiryHeight: ZcashBlockHeight, anchor: ZcashAnchor, flags: ZcashOrchardFlags) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashOrchardTransactionBuilder_new(
                    FfiConverterTypeZcashConsensusParameters.lower(parameters),
                    FfiConverterTypeZcashBlockHeight.lower(targetHeight),
                    FfiConverterTypeZcashBlockHeight.lower(expiryHeight),
                    FfiConverterTypeZcashAnchor.lower(anchor),
                    FfiConverterTypeZcashOrchardFlags.lower(flags), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free(pointer, $0) }
    }

    public func addSpend(fvk: ZcashOrchardFullViewingKey, note: ZcashOrchardNote, merklePath: ZcashOrchardMerklePath) {
        try!
            rustCall {
                zcash_e53_ZcashOrchardTransactionBuilder_add_spend(self.pointer,
                                                                   FfiConverterTypeZcashOrchardFullViewingKey.lower(fvk),
                                                                   FfiConverterTypeZcashOrchardNote.lower(note),
                                                                   FfiConverterTypeZcashOrchardMerklePath.lower(merklePath), $0)
            }
    }

    public func addRecipient(ovk: ZcashOrchardOutgoingViewingKey?, recipient: ZcashOrchardAddress, value: UInt64, memo: [UInt8]?) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardTransactionBuilder_add_recipient(self.pointer,
                                                                       FfiConverterOptionTypeZcashOrchardOutgoingViewingKey.lower(ovk),
                                                                       FfiConverterTypeZcashOrchardAddress.lower(recipient),
                                                                       FfiConverterUInt64.lower(value),
                                                                       FfiConverterOptionSequenceUInt8.lower(memo), $0)
            }
    }

    public func build(keys: [ZcashOrchardSpendingKey], sighash: [UInt8]) throws -> ZcashTransaction {
        return try FfiConverterTypeZcashTransaction.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOrchardTransactionBuilder_build(self.pointer,
                                                               FfiConverterSequenceTypeZcashOrchardSpendingKey.lower(keys),
                                                               FfiConverterSequenceUInt8.lower(sighash), $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashOrchardTransactionBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardTransactionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardTransactionBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardTransactionBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardTransactionBuilder {
        return ZcashOrchardTransactionBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardTransactionBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardTransactionBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardTransactionBuilder {
    return try FfiConverterTypeZcashOrchardTransactionBuilder.lift(pointer)
}

public func FfiConverterTypeZcashOrchardTransactionBuilder_lower(_ value: ZcashOrchardTransactionBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardTransactionBuilder.lower(value)
}

public protocol ZcashOrchardValueCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardValueCommitment: ZcashOrchardValueCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOrchardValueCommitment_object_free(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOrchardValueCommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardValueCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardValueCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardValueCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardValueCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardValueCommitment {
        return ZcashOrchardValueCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardValueCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardValueCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardValueCommitment {
    return try FfiConverterTypeZcashOrchardValueCommitment.lift(pointer)
}

public func FfiConverterTypeZcashOrchardValueCommitment_lower(_ value: ZcashOrchardValueCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardValueCommitment.lower(value)
}

public protocol ZcashOutPointProtocol {}

public class ZcashOutPoint: ZcashOutPointProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(hash: [UInt8], n: UInt32) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOutPoint_new(
                    FfiConverterSequenceUInt8.lower(hash),
                    FfiConverterUInt32.lower(n), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOutPoint_object_free(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashOutPoint: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOutPoint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutPoint {
        return ZcashOutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOutPoint) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutPoint {
    return try FfiConverterTypeZcashOutPoint.lift(pointer)
}

public func FfiConverterTypeZcashOutPoint_lower(_ value: ZcashOutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOutPoint.lower(value)
}

public protocol ZcashOutgoingViewingKeyProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOutgoingViewingKey: ZcashOutgoingViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashOutgoingViewingKey_object_free(pointer, $0) }
    }

    public static func fromBytes(b: [UInt8]) throws -> ZcashOutgoingViewingKey {
        return try ZcashOutgoingViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashOutgoingViewingKey_from_bytes(
                    FfiConverterSequenceUInt8.lower(b), $0
                )
            })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashOutgoingViewingKey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOutgoingViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOutgoingViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOutgoingViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOutgoingViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutgoingViewingKey {
        return ZcashOutgoingViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOutgoingViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOutgoingViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutgoingViewingKey {
    return try FfiConverterTypeZcashOutgoingViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOutgoingViewingKey_lower(_ value: ZcashOutgoingViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOutgoingViewingKey.lower(value)
}

public protocol ZcashPaymentAddressProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func toBytes() -> [UInt8]

    func diversifier() -> ZcashDiversifier

    func pkD() -> ZcashSaplingDiversifiedTransmissionKey

    func createNote(value: UInt64, rseed: ZcashRseed) throws -> ZcashSaplingNote
}

public class ZcashPaymentAddress: ZcashPaymentAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashPaymentAddress_object_free(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashPaymentAddress {
        return try ZcashPaymentAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashPaymentAddress_from_bytes(
                    FfiConverterSequenceUInt8.lower(bytes), $0
                )
            })
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashPaymentAddress {
        return try ZcashPaymentAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashPaymentAddress_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(input), $0
                )
            })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashPaymentAddress_encode(self.pointer,
                                                         FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashPaymentAddress_to_bytes(self.pointer, $0)
                }
        )
    }

    public func diversifier() -> ZcashDiversifier {
        return try! FfiConverterTypeZcashDiversifier.lift(
            try!
                rustCall {
                    zcash_e53_ZcashPaymentAddress_diversifier(self.pointer, $0)
                }
        )
    }

    public func pkD() -> ZcashSaplingDiversifiedTransmissionKey {
        return try! FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashPaymentAddress_pk_d(self.pointer, $0)
                }
        )
    }

    public func createNote(value: UInt64, rseed: ZcashRseed) throws -> ZcashSaplingNote {
        return try FfiConverterTypeZcashSaplingNote.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashPaymentAddress_create_note(self.pointer,
                                                          FfiConverterUInt64.lower(value),
                                                          FfiConverterTypeZcashRseed.lower(rseed), $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashPaymentAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashPaymentAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashPaymentAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashPaymentAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashPaymentAddress {
        return ZcashPaymentAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashPaymentAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashPaymentAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashPaymentAddress {
    return try FfiConverterTypeZcashPaymentAddress.lift(pointer)
}

public func FfiConverterTypeZcashPaymentAddress_lower(_ value: ZcashPaymentAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashPaymentAddress.lower(value)
}

public protocol ZcashProofGenerationKeyProtocol {
    func toViewingKey() -> ZcashViewingKey
}

public class ZcashProofGenerationKey: ZcashProofGenerationKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashProofGenerationKey_object_free(pointer, $0) }
    }

    public func toViewingKey() -> ZcashViewingKey {
        return try! FfiConverterTypeZcashViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashProofGenerationKey_to_viewing_key(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashProofGenerationKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashProofGenerationKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashProofGenerationKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashProofGenerationKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProofGenerationKey {
        return ZcashProofGenerationKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashProofGenerationKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashProofGenerationKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProofGenerationKey {
    return try FfiConverterTypeZcashProofGenerationKey.lift(pointer)
}

public func FfiConverterTypeZcashProofGenerationKey_lower(_ value: ZcashProofGenerationKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashProofGenerationKey.lower(value)
}

public protocol ZcashProvingKeyProtocol {}

public class ZcashProvingKey: ZcashProvingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashProvingKey_new($0)
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashProvingKey_object_free(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashProvingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashProvingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashProvingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashProvingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProvingKey {
        return ZcashProvingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashProvingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashProvingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProvingKey {
    return try FfiConverterTypeZcashProvingKey.lift(pointer)
}

public func FfiConverterTypeZcashProvingKey_lower(_ value: ZcashProvingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashProvingKey.lower(value)
}

public protocol ZcashRecipientAddressProtocol {
    func encode(params: ZcashConsensusParameters) -> String
}

public class ZcashRecipientAddress: ZcashRecipientAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashRecipientAddress_object_free(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, address: String) throws -> ZcashRecipientAddress {
        return try ZcashRecipientAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashRecipientAddress_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(address), $0
                )
            })
    }

    public static func shielded(addr: ZcashPaymentAddress) -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashRecipientAddress_shielded(
                    FfiConverterTypeZcashPaymentAddress.lower(addr), $0
                )
            })
    }

    public static func transparent(addr: ZcashTransparentAddress) -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashRecipientAddress_transparent(
                    FfiConverterTypeZcashTransparentAddress.lower(addr), $0
                )
            })
    }

    public static func unified(addr: ZcashUnifiedAddress) -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashRecipientAddress_unified(
                    FfiConverterTypeZcashUnifiedAddress.lower(addr), $0
                )
            })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashRecipientAddress_encode(self.pointer,
                                                           FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashRecipientAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashRecipientAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashRecipientAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashRecipientAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashRecipientAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashRecipientAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashRecipientAddress {
    return try FfiConverterTypeZcashRecipientAddress.lift(pointer)
}

public func FfiConverterTypeZcashRecipientAddress_lower(_ value: ZcashRecipientAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashRecipientAddress.lower(value)
}

public protocol ZcashSaplingBundleProtocol {
    func shieldedSpends() -> [ZcashSaplingSpendDescription]

    func shieldedOutputs() -> [ZcashSaplingOutputDescription]

    func valueBalance() -> ZcashAmount
}

public class ZcashSaplingBundle: ZcashSaplingBundleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingBundle_object_free(pointer, $0) }
    }

    public func shieldedSpends() -> [ZcashSaplingSpendDescription] {
        return try! FfiConverterSequenceTypeZcashSaplingSpendDescription.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingBundle_shielded_spends(self.pointer, $0)
                }
        )
    }

    public func shieldedOutputs() -> [ZcashSaplingOutputDescription] {
        return try! FfiConverterSequenceTypeZcashSaplingOutputDescription.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingBundle_shielded_outputs(self.pointer, $0)
                }
        )
    }

    public func valueBalance() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingBundle_value_balance(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingBundle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingBundle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingBundle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingBundle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingBundle {
        return ZcashSaplingBundle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingBundle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingBundle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingBundle {
    return try FfiConverterTypeZcashSaplingBundle.lift(pointer)
}

public func FfiConverterTypeZcashSaplingBundle_lower(_ value: ZcashSaplingBundle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingBundle.lower(value)
}

public protocol ZcashSaplingDiversifiedTransmissionKeyProtocol {}

public class ZcashSaplingDiversifiedTransmissionKey: ZcashSaplingDiversifiedTransmissionKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashSaplingDiversifiedTransmissionKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingDiversifiedTransmissionKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingDiversifiedTransmissionKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingDiversifiedTransmissionKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingDiversifiedTransmissionKey {
        return ZcashSaplingDiversifiedTransmissionKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingDiversifiedTransmissionKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingDiversifiedTransmissionKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingDiversifiedTransmissionKey {
    return try FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(pointer)
}

public func FfiConverterTypeZcashSaplingDiversifiedTransmissionKey_lower(_ value: ZcashSaplingDiversifiedTransmissionKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lower(value)
}

public protocol ZcashSaplingExtractedNoteCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashSaplingExtractedNoteCommitment: ZcashSaplingExtractedNoteCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashSaplingExtractedNoteCommitment_new(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingExtractedNoteCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingExtractedNoteCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingExtractedNoteCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingExtractedNoteCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingExtractedNoteCommitment {
        return ZcashSaplingExtractedNoteCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingExtractedNoteCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingExtractedNoteCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingExtractedNoteCommitment {
    return try FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(pointer)
}

public func FfiConverterTypeZcashSaplingExtractedNoteCommitment_lower(_ value: ZcashSaplingExtractedNoteCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(value)
}

public protocol ZcashSaplingIvkProtocol {
    func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?

    func toRepr() -> [UInt8]
}

public class ZcashSaplingIvk: ZcashSaplingIvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingIvk_object_free(pointer, $0) }
    }

    public func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingIvk_to_payment_address(self.pointer,
                                                                 FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func toRepr() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingIvk_to_repr(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingIvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingIvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingIvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingIvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingIvk {
        return ZcashSaplingIvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingIvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingIvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingIvk {
    return try FfiConverterTypeZcashSaplingIvk.lift(pointer)
}

public func FfiConverterTypeZcashSaplingIvk_lower(_ value: ZcashSaplingIvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingIvk.lower(value)
}

public protocol ZcashSaplingMerklePathProtocol {
    func authPath() -> [ZcashAuthPath]

    func position() -> UInt64
}

public class ZcashSaplingMerklePath: ZcashSaplingMerklePathProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingMerklePath_object_free(pointer, $0) }
    }

    public func authPath() -> [ZcashAuthPath] {
        return try! FfiConverterSequenceTypeZcashAuthPath.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingMerklePath_auth_path(self.pointer, $0)
                }
        )
    }

    public func position() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingMerklePath_position(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingMerklePath: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingMerklePath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingMerklePath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingMerklePath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMerklePath {
        return ZcashSaplingMerklePath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingMerklePath) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingMerklePath_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMerklePath {
    return try FfiConverterTypeZcashSaplingMerklePath.lift(pointer)
}

public func FfiConverterTypeZcashSaplingMerklePath_lower(_ value: ZcashSaplingMerklePath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingMerklePath.lower(value)
}

public protocol ZcashSaplingMetadataProtocol {
    func spendIndex(n: UInt64) -> UInt64?

    func outputIndex(n: UInt64) -> UInt64?
}

public class ZcashSaplingMetadata: ZcashSaplingMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashSaplingMetadata_new($0)
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingMetadata_object_free(pointer, $0) }
    }

    public func spendIndex(n: UInt64) -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingMetadata_spend_index(self.pointer,
                                                               FfiConverterUInt64.lower(n), $0)
                }
        )
    }

    public func outputIndex(n: UInt64) -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingMetadata_output_index(self.pointer,
                                                                FfiConverterUInt64.lower(n), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingMetadata: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMetadata {
        return ZcashSaplingMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingMetadata) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMetadata {
    return try FfiConverterTypeZcashSaplingMetadata.lift(pointer)
}

public func FfiConverterTypeZcashSaplingMetadata_lower(_ value: ZcashSaplingMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingMetadata.lower(value)
}

public protocol ZcashSaplingNodeProtocol {}

public class ZcashSaplingNode: ZcashSaplingNodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingNode_object_free(pointer, $0) }
    }

    public static func fromCmu(cmu: ZcashSaplingExtractedNoteCommitment) -> ZcashSaplingNode {
        return ZcashSaplingNode(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashSaplingNode_from_cmu(
                    FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(cmu), $0
                )
            })
    }
}

public struct FfiConverterTypeZcashSaplingNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNode {
        return ZcashSaplingNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNode {
    return try FfiConverterTypeZcashSaplingNode.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNode_lower(_ value: ZcashSaplingNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNode.lower(value)
}

public protocol ZcashSaplingNoteProtocol {
    func value() -> ZcashSaplingNoteValue

    func cmu() -> ZcashSaplingExtractedNoteCommitment
}

public class ZcashSaplingNote: ZcashSaplingNoteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingNote_object_free(pointer, $0) }
    }

    public static func fromParts(recipient: ZcashPaymentAddress, value: ZcashSaplingNoteValue, rseed: ZcashRseed) throws -> ZcashSaplingNote {
        return try ZcashSaplingNote(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashSaplingNote_from_parts(
                    FfiConverterTypeZcashPaymentAddress.lower(recipient),
                    FfiConverterTypeZcashSaplingNoteValue.lower(value),
                    FfiConverterTypeZcashRseed.lower(rseed), $0
                )
            })
    }

    public func value() -> ZcashSaplingNoteValue {
        return try! FfiConverterTypeZcashSaplingNoteValue.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingNote_value(self.pointer, $0)
                }
        )
    }

    public func cmu() -> ZcashSaplingExtractedNoteCommitment {
        return try! FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingNote_cmu(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingNote: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNote

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNote {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNote, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNote {
        return ZcashSaplingNote(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNote) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNote_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNote {
    return try FfiConverterTypeZcashSaplingNote.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNote_lower(_ value: ZcashSaplingNote) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNote.lower(value)
}

public protocol ZcashSaplingNoteValueProtocol {
    func inner() -> UInt64
}

public class ZcashSaplingNoteValue: ZcashSaplingNoteValueProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingNoteValue_object_free(pointer, $0) }
    }

    public static func fromRaw(data: UInt64) -> ZcashSaplingNoteValue {
        return ZcashSaplingNoteValue(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashSaplingNoteValue_from_raw(
                    FfiConverterUInt64.lower(data), $0
                )
            })
    }

    public func inner() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingNoteValue_inner(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingNoteValue: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNoteValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNoteValue {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNoteValue, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNoteValue {
        return ZcashSaplingNoteValue(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNoteValue) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNoteValue_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNoteValue {
    return try FfiConverterTypeZcashSaplingNoteValue.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNoteValue_lower(_ value: ZcashSaplingNoteValue) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNoteValue.lower(value)
}

public protocol ZcashSaplingNullifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashSaplingNullifier: ZcashSaplingNullifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingNullifier_object_free(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingNullifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingNullifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNullifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNullifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNullifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNullifier {
        return ZcashSaplingNullifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNullifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNullifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNullifier {
    return try FfiConverterTypeZcashSaplingNullifier.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNullifier_lower(_ value: ZcashSaplingNullifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNullifier.lower(value)
}

public protocol ZcashSaplingOutputDescriptionProtocol {
    func cv() -> ZcashSaplingValueCommitment

    func cmu() -> ZcashSaplingExtractedNoteCommitment
}

public class ZcashSaplingOutputDescription: ZcashSaplingOutputDescriptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingOutputDescription_object_free(pointer, $0) }
    }

    public func cv() -> ZcashSaplingValueCommitment {
        return try! FfiConverterTypeZcashSaplingValueCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingOutputDescription_cv(self.pointer, $0)
                }
        )
    }

    public func cmu() -> ZcashSaplingExtractedNoteCommitment {
        return try! FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingOutputDescription_cmu(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingOutputDescription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingOutputDescription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingOutputDescription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingOutputDescription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingOutputDescription {
        return ZcashSaplingOutputDescription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingOutputDescription) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingOutputDescription_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingOutputDescription {
    return try FfiConverterTypeZcashSaplingOutputDescription.lift(pointer)
}

public func FfiConverterTypeZcashSaplingOutputDescription_lower(_ value: ZcashSaplingOutputDescription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingOutputDescription.lower(value)
}

public protocol ZcashSaplingPublicKeyProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashSaplingPublicKey: ZcashSaplingPublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingPublicKey_object_free(pointer, $0) }
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashSaplingPublicKey_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashSaplingPublicKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingPublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingPublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingPublicKey {
        return ZcashSaplingPublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingPublicKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingPublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingPublicKey {
    return try FfiConverterTypeZcashSaplingPublicKey.lift(pointer)
}

public func FfiConverterTypeZcashSaplingPublicKey_lower(_ value: ZcashSaplingPublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingPublicKey.lower(value)
}

public protocol ZcashSaplingSpendDescriptionProtocol {
    func cv() -> ZcashSaplingValueCommitment

    func anchor() -> [UInt8]

    func nullifier() -> ZcashSaplingNullifier

    func rk() -> ZcashSaplingPublicKey
}

public class ZcashSaplingSpendDescription: ZcashSaplingSpendDescriptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingSpendDescription_object_free(pointer, $0) }
    }

    public func cv() -> ZcashSaplingValueCommitment {
        return try! FfiConverterTypeZcashSaplingValueCommitment.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingSpendDescription_cv(self.pointer, $0)
                }
        )
    }

    public func anchor() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingSpendDescription_anchor(self.pointer, $0)
                }
        )
    }

    public func nullifier() -> ZcashSaplingNullifier {
        return try! FfiConverterTypeZcashSaplingNullifier.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingSpendDescription_nullifier(self.pointer, $0)
                }
        )
    }

    public func rk() -> ZcashSaplingPublicKey {
        return try! FfiConverterTypeZcashSaplingPublicKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingSpendDescription_rk(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingSpendDescription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingSpendDescription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingSpendDescription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingSpendDescription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingSpendDescription {
        return ZcashSaplingSpendDescription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingSpendDescription) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingSpendDescription_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingSpendDescription {
    return try FfiConverterTypeZcashSaplingSpendDescription.lift(pointer)
}

public func FfiConverterTypeZcashSaplingSpendDescription_lower(_ value: ZcashSaplingSpendDescription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingSpendDescription.lower(value)
}

public protocol ZcashSaplingValueCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashSaplingValueCommitment: ZcashSaplingValueCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashSaplingValueCommitment_object_free(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashSaplingValueCommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingValueCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingValueCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingValueCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingValueCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingValueCommitment {
        return ZcashSaplingValueCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingValueCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingValueCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingValueCommitment {
    return try FfiConverterTypeZcashSaplingValueCommitment.lift(pointer)
}

public func FfiConverterTypeZcashSaplingValueCommitment_lower(_ value: ZcashSaplingValueCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingValueCommitment.lower(value)
}

public protocol ZcashScriptProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashScript: ZcashScriptProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashScript_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashScript {
        return try ZcashScript(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashScript_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashScript_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashScript: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashScript

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashScript {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashScript, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashScript {
        return ZcashScript(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashScript) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashScript_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashScript {
    return try FfiConverterTypeZcashScript.lift(pointer)
}

public func FfiConverterTypeZcashScript_lower(_ value: ZcashScript) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashScript.lower(value)
}

public protocol ZcashTransactionProtocol {
    func toBytes() throws -> [UInt8]

    func txid() -> ZcashTxId

    func version() -> ZcashTxVersion

    func consensusBranchId() -> ZcashBranchId

    func lockTime() -> UInt32

    func expiryHeight() -> ZcashBlockHeight

    func transparentBundle() -> ZcashTransparentBundle?

    func saplingBundle() -> ZcashSaplingBundle?

    func orchardBundle() -> ZcashOrchardBundle?
}

public class ZcashTransaction: ZcashTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTransaction_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8], consensusBranchId: ZcashBranchId) throws -> ZcashTransaction {
        return try ZcashTransaction(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTransaction_from_bytes(
                    FfiConverterSequenceUInt8.lower(data),
                    FfiConverterTypeZcashBranchId.lower(consensusBranchId), $0
                )
            })
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTransaction_to_bytes(self.pointer, $0)
            }
        )
    }

    public func txid() -> ZcashTxId {
        return try! FfiConverterTypeZcashTxId.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_txid(self.pointer, $0)
                }
        )
    }

    public func version() -> ZcashTxVersion {
        return try! FfiConverterTypeZcashTxVersion.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_version(self.pointer, $0)
                }
        )
    }

    public func consensusBranchId() -> ZcashBranchId {
        return try! FfiConverterTypeZcashBranchId.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_consensus_branch_id(self.pointer, $0)
                }
        )
    }

    public func lockTime() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_lock_time(self.pointer, $0)
                }
        )
    }

    public func expiryHeight() -> ZcashBlockHeight {
        return try! FfiConverterTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_expiry_height(self.pointer, $0)
                }
        )
    }

    public func transparentBundle() -> ZcashTransparentBundle? {
        return try! FfiConverterOptionTypeZcashTransparentBundle.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_transparent_bundle(self.pointer, $0)
                }
        )
    }

    public func saplingBundle() -> ZcashSaplingBundle? {
        return try! FfiConverterOptionTypeZcashSaplingBundle.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_sapling_bundle(self.pointer, $0)
                }
        )
    }

    public func orchardBundle() -> ZcashOrchardBundle? {
        return try! FfiConverterOptionTypeZcashOrchardBundle.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransaction_orchard_bundle(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransaction {
        return ZcashTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransaction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransaction {
    return try FfiConverterTypeZcashTransaction.lift(pointer)
}

public func FfiConverterTypeZcashTransaction_lower(_ value: ZcashTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransaction.lower(value)
}

public protocol ZcashTransactionBuilderProtocol {
    func addSaplingSpend(extsk: ZcashExtendedSpendingKey, diversifier: ZcashDiversifier, note: ZcashSaplingNote, merklePath: ZcashSaplingMerklePath)

    func addSaplingOutput(ovk: ZcashOutgoingViewingKey?, to: ZcashPaymentAddress, value: ZcashAmount, memo: ZcashMemoBytes)

    func addTransparentInput(sk: SecpSecretKey, utxo: ZcashOutPoint, coin: ZcashTxOut)

    func addTransparentOutput(to: ZcashTransparentAddress, value: ZcashAmount)

    func build(prover: ZcashLocalTxProver, feeRule: ZcashFeeRules) throws -> ZcashTransactionAndSaplingMetadata
}

public class ZcashTransactionBuilder: ZcashTransactionBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(parameters: ZcashConsensusParameters, blockHeight: ZcashBlockHeight) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashTransactionBuilder_new(
                    FfiConverterTypeZcashConsensusParameters.lower(parameters),
                    FfiConverterTypeZcashBlockHeight.lower(blockHeight), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTransactionBuilder_object_free(pointer, $0) }
    }

    public func addSaplingSpend(extsk: ZcashExtendedSpendingKey, diversifier: ZcashDiversifier, note: ZcashSaplingNote, merklePath: ZcashSaplingMerklePath) {
        try!
            rustCall {
                zcash_e53_ZcashTransactionBuilder_add_sapling_spend(self.pointer,
                                                                    FfiConverterTypeZcashExtendedSpendingKey.lower(extsk),
                                                                    FfiConverterTypeZcashDiversifier.lower(diversifier),
                                                                    FfiConverterTypeZcashSaplingNote.lower(note),
                                                                    FfiConverterTypeZcashSaplingMerklePath.lower(merklePath), $0)
            }
    }

    public func addSaplingOutput(ovk: ZcashOutgoingViewingKey?, to: ZcashPaymentAddress, value: ZcashAmount, memo: ZcashMemoBytes) {
        try!
            rustCall {
                zcash_e53_ZcashTransactionBuilder_add_sapling_output(self.pointer,
                                                                     FfiConverterOptionTypeZcashOutgoingViewingKey.lower(ovk),
                                                                     FfiConverterTypeZcashPaymentAddress.lower(to),
                                                                     FfiConverterTypeZcashAmount.lower(value),
                                                                     FfiConverterTypeZcashMemoBytes.lower(memo), $0)
            }
    }

    public func addTransparentInput(sk: SecpSecretKey, utxo: ZcashOutPoint, coin: ZcashTxOut) {
        try!
            rustCall {
                zcash_e53_ZcashTransactionBuilder_add_transparent_input(self.pointer,
                                                                        FfiConverterTypeSecpSecretKey.lower(sk),
                                                                        FfiConverterTypeZcashOutPoint.lower(utxo),
                                                                        FfiConverterTypeZcashTxOut.lower(coin), $0)
            }
    }

    public func addTransparentOutput(to: ZcashTransparentAddress, value: ZcashAmount) {
        try!
            rustCall {
                zcash_e53_ZcashTransactionBuilder_add_transparent_output(self.pointer,
                                                                         FfiConverterTypeZcashTransparentAddress.lower(to),
                                                                         FfiConverterTypeZcashAmount.lower(value), $0)
            }
    }

    public func build(prover: ZcashLocalTxProver, feeRule: ZcashFeeRules) throws -> ZcashTransactionAndSaplingMetadata {
        return try FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTransactionBuilder_build(self.pointer,
                                                        FfiConverterTypeZcashLocalTxProver.lower(prover),
                                                        FfiConverterTypeZcashFeeRules.lower(feeRule), $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashTransactionBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransactionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransactionBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransactionBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransactionBuilder {
        return ZcashTransactionBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransactionBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransactionBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransactionBuilder {
    return try FfiConverterTypeZcashTransactionBuilder.lift(pointer)
}

public func FfiConverterTypeZcashTransactionBuilder_lower(_ value: ZcashTransactionBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransactionBuilder.lower(value)
}

public protocol ZcashTransparentAddressProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func isPublicKey() -> Bool

    func isScript() -> Bool

    func script() -> ZcashScript

    func toBytes() -> [UInt8]
}

public class ZcashTransparentAddress: ZcashTransparentAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTransparentAddress_object_free(pointer, $0) }
    }

    public static func fromPublicKey(data: [UInt8]) throws -> ZcashTransparentAddress {
        return try ZcashTransparentAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTransparentAddress_from_public_key(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func fromScript(data: [UInt8]) throws -> ZcashTransparentAddress {
        return try ZcashTransparentAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTransparentAddress_from_script(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashTransparentAddress {
        return try ZcashTransparentAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTransparentAddress_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(input), $0
                )
            })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentAddress_encode(self.pointer,
                                                             FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func isPublicKey() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentAddress_is_public_key(self.pointer, $0)
                }
        )
    }

    public func isScript() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentAddress_is_script(self.pointer, $0)
                }
        )
    }

    public func script() -> ZcashScript {
        return try! FfiConverterTypeZcashScript.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentAddress_script(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentAddress_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransparentAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransparentAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransparentAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransparentAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentAddress {
        return ZcashTransparentAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransparentAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransparentAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentAddress {
    return try FfiConverterTypeZcashTransparentAddress.lift(pointer)
}

public func FfiConverterTypeZcashTransparentAddress_lower(_ value: ZcashTransparentAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransparentAddress.lower(value)
}

public protocol ZcashTransparentBundleProtocol {
    func isCoinbase() -> Bool

    func vin() -> [ZcashTxIn]

    func vout() -> [ZcashTxOut]
}

public class ZcashTransparentBundle: ZcashTransparentBundleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTransparentBundle_object_free(pointer, $0) }
    }

    public func isCoinbase() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentBundle_is_coinbase(self.pointer, $0)
                }
        )
    }

    public func vin() -> [ZcashTxIn] {
        return try! FfiConverterSequenceTypeZcashTxIn.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentBundle_vin(self.pointer, $0)
                }
        )
    }

    public func vout() -> [ZcashTxOut] {
        return try! FfiConverterSequenceTypeZcashTxOut.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTransparentBundle_vout(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransparentBundle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransparentBundle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransparentBundle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransparentBundle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentBundle {
        return ZcashTransparentBundle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransparentBundle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransparentBundle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentBundle {
    return try FfiConverterTypeZcashTransparentBundle.lift(pointer)
}

public func FfiConverterTypeZcashTransparentBundle_lower(_ value: ZcashTransparentBundle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransparentBundle.lower(value)
}

public protocol ZcashTxIdProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashTxId: ZcashTxIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTxId_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashTxId {
        return try ZcashTxId(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTxId_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTxId_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashTxId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxId {
        return ZcashTxId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxId_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxId {
    return try FfiConverterTypeZcashTxId.lift(pointer)
}

public func FfiConverterTypeZcashTxId_lower(_ value: ZcashTxId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxId.lower(value)
}

public protocol ZcashTxInProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashTxIn: ZcashTxInProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTxIn_object_free(pointer, $0) }
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTxIn_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashTxIn: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxIn

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxIn {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxIn, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxIn {
        return ZcashTxIn(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxIn) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxIn_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxIn {
    return try FfiConverterTypeZcashTxIn.lift(pointer)
}

public func FfiConverterTypeZcashTxIn_lower(_ value: ZcashTxIn) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxIn.lower(value)
}

public protocol ZcashTxOutProtocol {
    func value() -> ZcashAmount

    func scriptPubkey() -> ZcashScript

    func toBytes() throws -> [UInt8]

    func recipientAddress() -> ZcashTransparentAddress?
}

public class ZcashTxOut: ZcashTxOutProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(value: ZcashAmount, scriptPubkey: ZcashScript) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashTxOut_new(
                    FfiConverterTypeZcashAmount.lower(value),
                    FfiConverterTypeZcashScript.lower(scriptPubkey), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTxOut_object_free(pointer, $0) }
    }

    public func value() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxOut_value(self.pointer, $0)
                }
        )
    }

    public func scriptPubkey() -> ZcashScript {
        return try! FfiConverterTypeZcashScript.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxOut_script_pubkey(self.pointer, $0)
                }
        )
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTxOut_to_bytes(self.pointer, $0)
            }
        )
    }

    public func recipientAddress() -> ZcashTransparentAddress? {
        return try! FfiConverterOptionTypeZcashTransparentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxOut_recipient_address(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTxOut: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxOut

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxOut {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxOut, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxOut {
        return ZcashTxOut(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxOut) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxOut_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxOut {
    return try FfiConverterTypeZcashTxOut.lift(pointer)
}

public func FfiConverterTypeZcashTxOut_lower(_ value: ZcashTxOut) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxOut.lower(value)
}

public protocol ZcashTxVersionProtocol {
    func selection() -> ZcashTxVersionSelection

    func header() -> UInt32

    func versionGroupId() -> UInt32

    func toBytes() throws -> [UInt8]

    func hasSprout() -> Bool

    func hasOverwinter() -> Bool

    func hasSapling() -> Bool

    func hasOrchard() -> Bool
}

public class ZcashTxVersion: ZcashTxVersionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashTxVersion_object_free(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashTxVersion {
        return try ZcashTxVersion(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTxVersion_from_bytes(
                    FfiConverterSequenceUInt8.lower(data), $0
                )
            })
    }

    public static func suggestedForBranch(consensusBranchId: ZcashBranchId) -> ZcashTxVersion {
        return ZcashTxVersion(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashTxVersion_suggested_for_branch(
                    FfiConverterTypeZcashBranchId.lower(consensusBranchId), $0
                )
            })
    }

    public func selection() -> ZcashTxVersionSelection {
        return try! FfiConverterTypeZcashTxVersionSelection.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_selection(self.pointer, $0)
                }
        )
    }

    public func header() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_header(self.pointer, $0)
                }
        )
    }

    public func versionGroupId() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_version_group_id(self.pointer, $0)
                }
        )
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashTxVersion_to_bytes(self.pointer, $0)
            }
        )
    }

    public func hasSprout() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_has_sprout(self.pointer, $0)
                }
        )
    }

    public func hasOverwinter() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_has_overwinter(self.pointer, $0)
                }
        )
    }

    public func hasSapling() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_has_sapling(self.pointer, $0)
                }
        )
    }

    public func hasOrchard() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    zcash_e53_ZcashTxVersion_has_orchard(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTxVersion: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxVersion {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxVersion, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxVersion {
        return ZcashTxVersion(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxVersion) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxVersion_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxVersion {
    return try FfiConverterTypeZcashTxVersion.lift(pointer)
}

public func FfiConverterTypeZcashTxVersion_lower(_ value: ZcashTxVersion) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxVersion.lower(value)
}

public protocol ZcashUnifiedAddressProtocol {
    func orchard() -> ZcashOrchardAddress?

    func sapling() -> ZcashPaymentAddress?

    func transparent() -> ZcashTransparentAddress?

    func encode(params: ZcashConsensusParameters) -> String
}

public class ZcashUnifiedAddress: ZcashUnifiedAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(orchard: ZcashOrchardAddress?, sapling: ZcashPaymentAddress?, transparent: ZcashTransparentAddress?) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashUnifiedAddress_new(
                    FfiConverterOptionTypeZcashOrchardAddress.lower(orchard),
                    FfiConverterOptionTypeZcashPaymentAddress.lower(sapling),
                    FfiConverterOptionTypeZcashTransparentAddress.lower(transparent), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashUnifiedAddress_object_free(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, address: String) throws -> ZcashUnifiedAddress {
        return try ZcashUnifiedAddress(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashUnifiedAddress_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(address), $0
                )
            })
    }

    public func orchard() -> ZcashOrchardAddress? {
        return try! FfiConverterOptionTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedAddress_orchard(self.pointer, $0)
                }
        )
    }

    public func sapling() -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedAddress_sapling(self.pointer, $0)
                }
        )
    }

    public func transparent() -> ZcashTransparentAddress? {
        return try! FfiConverterOptionTypeZcashTransparentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedAddress_transparent(self.pointer, $0)
                }
        )
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedAddress_encode(self.pointer,
                                                         FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashUnifiedAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashUnifiedAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashUnifiedAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedAddress {
        return ZcashUnifiedAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashUnifiedAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashUnifiedAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedAddress {
    return try FfiConverterTypeZcashUnifiedAddress.lift(pointer)
}

public func FfiConverterTypeZcashUnifiedAddress_lower(_ value: ZcashUnifiedAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashUnifiedAddress.lower(value)
}

public protocol ZcashUnifiedFullViewingKeyProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func transparent() -> ZcashAccountPubKey?

    func sapling() -> ZcashDiversifiableFullViewingKey?

    func orchard() -> ZcashOrchardFullViewingKey?

    func address(j: ZcashDiversifierIndex) -> ZcashUnifiedAddress?

    func findAddress(j: ZcashDiversifierIndex) -> ZcashUnifiedAddressAndDiversifierIndex?

    func defaultAddress() -> ZcashUnifiedAddressAndDiversifierIndex
}

public class ZcashUnifiedFullViewingKey: ZcashUnifiedFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(transparent: ZcashAccountPubKey?, sapling: ZcashDiversifiableFullViewingKey?, orchard: ZcashOrchardFullViewingKey?) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashUnifiedFullViewingKey_new(
                    FfiConverterOptionTypeZcashAccountPubKey.lower(transparent),
                    FfiConverterOptionTypeZcashDiversifiableFullViewingKey.lower(sapling),
                    FfiConverterOptionTypeZcashOrchardFullViewingKey.lower(orchard), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, encoded: String) throws -> ZcashUnifiedFullViewingKey {
        return try ZcashUnifiedFullViewingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashUnifiedFullViewingKey_decode(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterString.lower(encoded), $0
                )
            })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_encode(self.pointer,
                                                                FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func transparent() -> ZcashAccountPubKey? {
        return try! FfiConverterOptionTypeZcashAccountPubKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_transparent(self.pointer, $0)
                }
        )
    }

    public func sapling() -> ZcashDiversifiableFullViewingKey? {
        return try! FfiConverterOptionTypeZcashDiversifiableFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_sapling(self.pointer, $0)
                }
        )
    }

    public func orchard() -> ZcashOrchardFullViewingKey? {
        return try! FfiConverterOptionTypeZcashOrchardFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_orchard(self.pointer, $0)
                }
        )
    }

    public func address(j: ZcashDiversifierIndex) -> ZcashUnifiedAddress? {
        return try! FfiConverterOptionTypeZcashUnifiedAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_address(self.pointer,
                                                                 FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func findAddress(j: ZcashDiversifierIndex) -> ZcashUnifiedAddressAndDiversifierIndex? {
        return try! FfiConverterOptionTypeZcashUnifiedAddressAndDiversifierIndex.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_find_address(self.pointer,
                                                                      FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashUnifiedAddressAndDiversifierIndex {
        return try! FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedFullViewingKey_default_address(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashUnifiedFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashUnifiedFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashUnifiedFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedFullViewingKey {
        return ZcashUnifiedFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashUnifiedFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashUnifiedFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedFullViewingKey {
    return try FfiConverterTypeZcashUnifiedFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashUnifiedFullViewingKey_lower(_ value: ZcashUnifiedFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashUnifiedFullViewingKey.lower(value)
}

public protocol ZcashUnifiedSpendingKeyProtocol {
    func toUnifiedFullViewingKey() -> ZcashUnifiedFullViewingKey

    func transparent() -> ZcashAccountPrivKey

    func sapling() -> ZcashExtendedSpendingKey

    func orchard() -> ZcashOrchardSpendingKey

    func toBytes(era: ZcashKeysEra) -> [UInt8]
}

public class ZcashUnifiedSpendingKey: ZcashUnifiedSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free(pointer, $0) }
    }

    public static func fromSeed(params: ZcashConsensusParameters, seed: [UInt8], accountId: ZcashAccountId) throws -> ZcashUnifiedSpendingKey {
        return try ZcashUnifiedSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashUnifiedSpendingKey_from_seed(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterSequenceUInt8.lower(seed),
                    FfiConverterTypeZcashAccountId.lower(accountId), $0
                )
            })
    }

    public static func fromBytes(era: ZcashKeysEra, encoded: [UInt8]) throws -> ZcashUnifiedSpendingKey {
        return try ZcashUnifiedSpendingKey(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashUnifiedSpendingKey_from_bytes(
                    FfiConverterTypeZcashKeysEra.lower(era),
                    FfiConverterSequenceUInt8.lower(encoded), $0
                )
            })
    }

    public func toUnifiedFullViewingKey() -> ZcashUnifiedFullViewingKey {
        return try! FfiConverterTypeZcashUnifiedFullViewingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key(self.pointer, $0)
                }
        )
    }

    public func transparent() -> ZcashAccountPrivKey {
        return try! FfiConverterTypeZcashAccountPrivKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedSpendingKey_transparent(self.pointer, $0)
                }
        )
    }

    public func sapling() -> ZcashExtendedSpendingKey {
        return try! FfiConverterTypeZcashExtendedSpendingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedSpendingKey_sapling(self.pointer, $0)
                }
        )
    }

    public func orchard() -> ZcashOrchardSpendingKey {
        return try! FfiConverterTypeZcashOrchardSpendingKey.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedSpendingKey_orchard(self.pointer, $0)
                }
        )
    }

    public func toBytes(era: ZcashKeysEra) -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    zcash_e53_ZcashUnifiedSpendingKey_to_bytes(self.pointer,
                                                               FfiConverterTypeZcashKeysEra.lower(era), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashUnifiedSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashUnifiedSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashUnifiedSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedSpendingKey {
        return ZcashUnifiedSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashUnifiedSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashUnifiedSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedSpendingKey {
    return try FfiConverterTypeZcashUnifiedSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashUnifiedSpendingKey_lower(_ value: ZcashUnifiedSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashUnifiedSpendingKey.lower(value)
}

public protocol ZcashVerifyingKeyProtocol {}

public class ZcashVerifyingKey: ZcashVerifyingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashVerifyingKey_new($0)
            })
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashVerifyingKey_object_free(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashVerifyingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashVerifyingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashVerifyingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashVerifyingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashVerifyingKey {
        return ZcashVerifyingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashVerifyingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashVerifyingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashVerifyingKey {
    return try FfiConverterTypeZcashVerifyingKey.lift(pointer)
}

public func FfiConverterTypeZcashVerifyingKey_lower(_ value: ZcashVerifyingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashVerifyingKey.lower(value)
}

public protocol ZcashViewingKeyProtocol {
    func ivk() -> ZcashSaplingIvk

    func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?
}

public class ZcashViewingKey: ZcashViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashViewingKey_object_free(pointer, $0) }
    }

    public func ivk() -> ZcashSaplingIvk {
        return try! FfiConverterTypeZcashSaplingIvk.lift(
            try!
                rustCall {
                    zcash_e53_ZcashViewingKey_ivk(self.pointer, $0)
                }
        )
    }

    public func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    zcash_e53_ZcashViewingKey_to_payment_address(self.pointer,
                                                                 FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashViewingKey {
        return ZcashViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashViewingKey {
    return try FfiConverterTypeZcashViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashViewingKey_lower(_ value: ZcashViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashViewingKey.lower(value)
}

public protocol ZcashZip317FeeRuleProtocol {
    func marginalFee() -> ZcashAmount
}

public class ZcashZip317FeeRule: ZcashZip317FeeRuleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_zcash_e53_ZcashZip317FeeRule_object_free(pointer, $0) }
    }

    public static func standard() -> ZcashZip317FeeRule {
        return ZcashZip317FeeRule(unsafeFromRawPointer: try!

            rustCall {
                zcash_e53_ZcashZip317FeeRule_standard($0)
            })
    }

    public static func nonStandard(marginalFee: ZcashAmount, graceActions: UInt64, p2pkhStandardInputSize: UInt64, p2pkhStandardOutputSize: UInt64) throws -> ZcashZip317FeeRule {
        return try ZcashZip317FeeRule(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeZcashError.self) {
                zcash_e53_ZcashZip317FeeRule_non_standard(
                    FfiConverterTypeZcashAmount.lower(marginalFee),
                    FfiConverterUInt64.lower(graceActions),
                    FfiConverterUInt64.lower(p2pkhStandardInputSize),
                    FfiConverterUInt64.lower(p2pkhStandardOutputSize), $0
                )
            })
    }

    public func marginalFee() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    zcash_e53_ZcashZip317FeeRule_marginal_fee(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashZip317FeeRule: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashZip317FeeRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashZip317FeeRule {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashZip317FeeRule, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashZip317FeeRule {
        return ZcashZip317FeeRule(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashZip317FeeRule) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashZip317FeeRule_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashZip317FeeRule {
    return try FfiConverterTypeZcashZip317FeeRule.lift(pointer)
}

public func FfiConverterTypeZcashZip317FeeRule_lower(_ value: ZcashZip317FeeRule) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashZip317FeeRule.lower(value)
}

public struct ZcashAccountId {
    public var id: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt32) {
        self.id = id
    }
}

extension ZcashAccountId: Equatable, Hashable {
    public static func == (lhs: ZcashAccountId, rhs: ZcashAccountId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

public struct FfiConverterTypeZcashAccountId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountId {
        return try ZcashAccountId(
            id: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashAccountId, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.id, into: &buf)
    }
}

public func FfiConverterTypeZcashAccountId_lift(_ buf: RustBuffer) throws -> ZcashAccountId {
    return try FfiConverterTypeZcashAccountId.lift(buf)
}

public func FfiConverterTypeZcashAccountId_lower(_ value: ZcashAccountId) -> RustBuffer {
    return FfiConverterTypeZcashAccountId.lower(value)
}

public struct ZcashAuthPath {
    public var node: ZcashSaplingNode
    public var bool: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(node: ZcashSaplingNode, bool: Bool) {
        self.node = node
        self.bool = bool
    }
}

public struct FfiConverterTypeZcashAuthPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAuthPath {
        return try ZcashAuthPath(
            node: FfiConverterTypeZcashSaplingNode.read(from: &buf),
            bool: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashAuthPath, into buf: inout [UInt8]) {
        FfiConverterTypeZcashSaplingNode.write(value.node, into: &buf)
        FfiConverterBool.write(value.bool, into: &buf)
    }
}

public func FfiConverterTypeZcashAuthPath_lift(_ buf: RustBuffer) throws -> ZcashAuthPath {
    return try FfiConverterTypeZcashAuthPath.lift(buf)
}

public func FfiConverterTypeZcashAuthPath_lower(_ value: ZcashAuthPath) -> RustBuffer {
    return FfiConverterTypeZcashAuthPath.lower(value)
}

public struct ZcashDiversifierIndexAndPaymentAddress {
    public var diversifierIndex: ZcashDiversifierIndex
    public var address: ZcashPaymentAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(diversifierIndex: ZcashDiversifierIndex, address: ZcashPaymentAddress) {
        self.diversifierIndex = diversifierIndex
        self.address = address
    }
}

public struct FfiConverterTypeZcashDiversifierIndexAndPaymentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifierIndexAndPaymentAddress {
        return try ZcashDiversifierIndexAndPaymentAddress(
            diversifierIndex: FfiConverterTypeZcashDiversifierIndex.read(from: &buf),
            address: FfiConverterTypeZcashPaymentAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashDiversifierIndexAndPaymentAddress, into buf: inout [UInt8]) {
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifierIndex, into: &buf)
        FfiConverterTypeZcashPaymentAddress.write(value.address, into: &buf)
    }
}

public func FfiConverterTypeZcashDiversifierIndexAndPaymentAddress_lift(_ buf: RustBuffer) throws -> ZcashDiversifierIndexAndPaymentAddress {
    return try FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(buf)
}

public func FfiConverterTypeZcashDiversifierIndexAndPaymentAddress_lower(_ value: ZcashDiversifierIndexAndPaymentAddress) -> RustBuffer {
    return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lower(value)
}

public struct ZcashDiversifierIndexAndScope {
    public var diversifierIndex: ZcashDiversifierIndex
    public var scope: ZcashScope

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(diversifierIndex: ZcashDiversifierIndex, scope: ZcashScope) {
        self.diversifierIndex = diversifierIndex
        self.scope = scope
    }
}

public struct FfiConverterTypeZcashDiversifierIndexAndScope: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifierIndexAndScope {
        return try ZcashDiversifierIndexAndScope(
            diversifierIndex: FfiConverterTypeZcashDiversifierIndex.read(from: &buf),
            scope: FfiConverterTypeZcashScope.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashDiversifierIndexAndScope, into buf: inout [UInt8]) {
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifierIndex, into: &buf)
        FfiConverterTypeZcashScope.write(value.scope, into: &buf)
    }
}

public func FfiConverterTypeZcashDiversifierIndexAndScope_lift(_ buf: RustBuffer) throws -> ZcashDiversifierIndexAndScope {
    return try FfiConverterTypeZcashDiversifierIndexAndScope.lift(buf)
}

public func FfiConverterTypeZcashDiversifierIndexAndScope_lower(_ value: ZcashDiversifierIndexAndScope) -> RustBuffer {
    return FfiConverterTypeZcashDiversifierIndexAndScope.lower(value)
}

public struct ZcashInternalOvkExternalOvk {
    public var internalOvk: ZcashInternalOvk
    public var externalOvk: ZcashExternalOvk

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(internalOvk: ZcashInternalOvk, externalOvk: ZcashExternalOvk) {
        self.internalOvk = internalOvk
        self.externalOvk = externalOvk
    }
}

public struct FfiConverterTypeZcashInternalOvkExternalOvk: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashInternalOvkExternalOvk {
        return try ZcashInternalOvkExternalOvk(
            internalOvk: FfiConverterTypeZcashInternalOvk.read(from: &buf),
            externalOvk: FfiConverterTypeZcashExternalOvk.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashInternalOvkExternalOvk, into buf: inout [UInt8]) {
        FfiConverterTypeZcashInternalOvk.write(value.internalOvk, into: &buf)
        FfiConverterTypeZcashExternalOvk.write(value.externalOvk, into: &buf)
    }
}

public func FfiConverterTypeZcashInternalOvkExternalOvk_lift(_ buf: RustBuffer) throws -> ZcashInternalOvkExternalOvk {
    return try FfiConverterTypeZcashInternalOvkExternalOvk.lift(buf)
}

public func FfiConverterTypeZcashInternalOvkExternalOvk_lower(_ value: ZcashInternalOvkExternalOvk) -> RustBuffer {
    return FfiConverterTypeZcashInternalOvkExternalOvk.lower(value)
}

public struct ZcashOrchardDecryptOutput {
    public var note: ZcashOrchardNote
    public var address: ZcashOrchardAddress
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(note: ZcashOrchardNote, address: ZcashOrchardAddress, data: [UInt8]) {
        self.note = note
        self.address = address
        self.data = data
    }
}

public struct FfiConverterTypeZcashOrchardDecryptOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDecryptOutput {
        return try ZcashOrchardDecryptOutput(
            note: FfiConverterTypeZcashOrchardNote.read(from: &buf),
            address: FfiConverterTypeZcashOrchardAddress.read(from: &buf),
            data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardDecryptOutput, into buf: inout [UInt8]) {
        FfiConverterTypeZcashOrchardNote.write(value.note, into: &buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardDecryptOutput_lift(_ buf: RustBuffer) throws -> ZcashOrchardDecryptOutput {
    return try FfiConverterTypeZcashOrchardDecryptOutput.lift(buf)
}

public func FfiConverterTypeZcashOrchardDecryptOutput_lower(_ value: ZcashOrchardDecryptOutput) -> RustBuffer {
    return FfiConverterTypeZcashOrchardDecryptOutput.lower(value)
}

public struct ZcashOrchardDecryptOutputForIncomingKeys {
    public var idx: UInt64
    public var key: ZcashOrchardIncomingViewingKey
    public var note: ZcashOrchardNote
    public var address: ZcashOrchardAddress
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idx: UInt64, key: ZcashOrchardIncomingViewingKey, note: ZcashOrchardNote, address: ZcashOrchardAddress, data: [UInt8]) {
        self.idx = idx
        self.key = key
        self.note = note
        self.address = address
        self.data = data
    }
}

public struct FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDecryptOutputForIncomingKeys {
        return try ZcashOrchardDecryptOutputForIncomingKeys(
            idx: FfiConverterUInt64.read(from: &buf),
            key: FfiConverterTypeZcashOrchardIncomingViewingKey.read(from: &buf),
            note: FfiConverterTypeZcashOrchardNote.read(from: &buf),
            address: FfiConverterTypeZcashOrchardAddress.read(from: &buf),
            data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardDecryptOutputForIncomingKeys, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.idx, into: &buf)
        FfiConverterTypeZcashOrchardIncomingViewingKey.write(value.key, into: &buf)
        FfiConverterTypeZcashOrchardNote.write(value.note, into: &buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys_lift(_ buf: RustBuffer) throws -> ZcashOrchardDecryptOutputForIncomingKeys {
    return try FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.lift(buf)
}

public func FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys_lower(_ value: ZcashOrchardDecryptOutputForIncomingKeys) -> RustBuffer {
    return FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.lower(value)
}

public struct ZcashOrchardDecryptOutputForOutgoingKeys {
    public var idx: UInt64
    public var key: ZcashOrchardOutgoingViewingKey
    public var note: ZcashOrchardNote
    public var address: ZcashOrchardAddress
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idx: UInt64, key: ZcashOrchardOutgoingViewingKey, note: ZcashOrchardNote, address: ZcashOrchardAddress, data: [UInt8]) {
        self.idx = idx
        self.key = key
        self.note = note
        self.address = address
        self.data = data
    }
}

public struct FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDecryptOutputForOutgoingKeys {
        return try ZcashOrchardDecryptOutputForOutgoingKeys(
            idx: FfiConverterUInt64.read(from: &buf),
            key: FfiConverterTypeZcashOrchardOutgoingViewingKey.read(from: &buf),
            note: FfiConverterTypeZcashOrchardNote.read(from: &buf),
            address: FfiConverterTypeZcashOrchardAddress.read(from: &buf),
            data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardDecryptOutputForOutgoingKeys, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.idx, into: &buf)
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value.key, into: &buf)
        FfiConverterTypeZcashOrchardNote.write(value.note, into: &buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys_lift(_ buf: RustBuffer) throws -> ZcashOrchardDecryptOutputForOutgoingKeys {
    return try FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(buf)
}

public func FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys_lower(_ value: ZcashOrchardDecryptOutputForOutgoingKeys) -> RustBuffer {
    return FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.lower(value)
}

public struct ZcashOrchardTransmittedNoteCiphertext {
    public var epkBytes: [UInt8]
    public var encCiphertext: [UInt8]
    public var outCiphertext: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epkBytes: [UInt8], encCiphertext: [UInt8], outCiphertext: [UInt8]) {
        self.epkBytes = epkBytes
        self.encCiphertext = encCiphertext
        self.outCiphertext = outCiphertext
    }
}

extension ZcashOrchardTransmittedNoteCiphertext: Equatable, Hashable {
    public static func == (lhs: ZcashOrchardTransmittedNoteCiphertext, rhs: ZcashOrchardTransmittedNoteCiphertext) -> Bool {
        if lhs.epkBytes != rhs.epkBytes {
            return false
        }
        if lhs.encCiphertext != rhs.encCiphertext {
            return false
        }
        if lhs.outCiphertext != rhs.outCiphertext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(epkBytes)
        hasher.combine(encCiphertext)
        hasher.combine(outCiphertext)
    }
}

public struct FfiConverterTypeZcashOrchardTransmittedNoteCiphertext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardTransmittedNoteCiphertext {
        return try ZcashOrchardTransmittedNoteCiphertext(
            epkBytes: FfiConverterSequenceUInt8.read(from: &buf),
            encCiphertext: FfiConverterSequenceUInt8.read(from: &buf),
            outCiphertext: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardTransmittedNoteCiphertext, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.epkBytes, into: &buf)
        FfiConverterSequenceUInt8.write(value.encCiphertext, into: &buf)
        FfiConverterSequenceUInt8.write(value.outCiphertext, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardTransmittedNoteCiphertext_lift(_ buf: RustBuffer) throws -> ZcashOrchardTransmittedNoteCiphertext {
    return try FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(buf)
}

public func FfiConverterTypeZcashOrchardTransmittedNoteCiphertext_lower(_ value: ZcashOrchardTransmittedNoteCiphertext) -> RustBuffer {
    return FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lower(value)
}

public struct ZcashPayment {
    public var recipentAddress: ZcashRecipientAddress
    public var amount: Int64
    public var memo: ZcashMemoBytes?
    public var label: String?
    public var message: String?
    public var otherParams: [ZcashPaymentParam]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipentAddress: ZcashRecipientAddress, amount: Int64, memo: ZcashMemoBytes?, label: String?, message: String?, otherParams: [ZcashPaymentParam]) {
        self.recipentAddress = recipentAddress
        self.amount = amount
        self.memo = memo
        self.label = label
        self.message = message
        self.otherParams = otherParams
    }
}

public struct FfiConverterTypeZcashPayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashPayment {
        return try ZcashPayment(
            recipentAddress: FfiConverterTypeZcashRecipientAddress.read(from: &buf),
            amount: FfiConverterInt64.read(from: &buf),
            memo: FfiConverterOptionTypeZcashMemoBytes.read(from: &buf),
            label: FfiConverterOptionString.read(from: &buf),
            message: FfiConverterOptionString.read(from: &buf),
            otherParams: FfiConverterSequenceTypeZcashPaymentParam.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashPayment, into buf: inout [UInt8]) {
        FfiConverterTypeZcashRecipientAddress.write(value.recipentAddress, into: &buf)
        FfiConverterInt64.write(value.amount, into: &buf)
        FfiConverterOptionTypeZcashMemoBytes.write(value.memo, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterSequenceTypeZcashPaymentParam.write(value.otherParams, into: &buf)
    }
}

public func FfiConverterTypeZcashPayment_lift(_ buf: RustBuffer) throws -> ZcashPayment {
    return try FfiConverterTypeZcashPayment.lift(buf)
}

public func FfiConverterTypeZcashPayment_lower(_ value: ZcashPayment) -> RustBuffer {
    return FfiConverterTypeZcashPayment.lower(value)
}

public struct ZcashPaymentParam {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}

extension ZcashPaymentParam: Equatable, Hashable {
    public static func == (lhs: ZcashPaymentParam, rhs: ZcashPaymentParam) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}

public struct FfiConverterTypeZcashPaymentParam: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashPaymentParam {
        return try ZcashPaymentParam(
            key: FfiConverterString.read(from: &buf),
            value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashPaymentParam, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeZcashPaymentParam_lift(_ buf: RustBuffer) throws -> ZcashPaymentParam {
    return try FfiConverterTypeZcashPaymentParam.lift(buf)
}

public func FfiConverterTypeZcashPaymentParam_lower(_ value: ZcashPaymentParam) -> RustBuffer {
    return FfiConverterTypeZcashPaymentParam.lower(value)
}

public struct ZcashTransactionAndSaplingMetadata {
    public var transaction: ZcashTransaction
    public var saplingMetadata: ZcashSaplingMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: ZcashTransaction, saplingMetadata: ZcashSaplingMetadata) {
        self.transaction = transaction
        self.saplingMetadata = saplingMetadata
    }
}

public struct FfiConverterTypeZcashTransactionAndSaplingMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransactionAndSaplingMetadata {
        return try ZcashTransactionAndSaplingMetadata(
            transaction: FfiConverterTypeZcashTransaction.read(from: &buf),
            saplingMetadata: FfiConverterTypeZcashSaplingMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashTransactionAndSaplingMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeZcashTransaction.write(value.transaction, into: &buf)
        FfiConverterTypeZcashSaplingMetadata.write(value.saplingMetadata, into: &buf)
    }
}

public func FfiConverterTypeZcashTransactionAndSaplingMetadata_lift(_ buf: RustBuffer) throws -> ZcashTransactionAndSaplingMetadata {
    return try FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(buf)
}

public func FfiConverterTypeZcashTransactionAndSaplingMetadata_lower(_ value: ZcashTransactionAndSaplingMetadata) -> RustBuffer {
    return FfiConverterTypeZcashTransactionAndSaplingMetadata.lower(value)
}

public struct ZcashTransparentAddressAndIndex {
    public var transparentAddress: ZcashTransparentAddress
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transparentAddress: ZcashTransparentAddress, index: UInt32) {
        self.transparentAddress = transparentAddress
        self.index = index
    }
}

public struct FfiConverterTypeZcashTransparentAddressAndIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransparentAddressAndIndex {
        return try ZcashTransparentAddressAndIndex(
            transparentAddress: FfiConverterTypeZcashTransparentAddress.read(from: &buf),
            index: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashTransparentAddressAndIndex, into buf: inout [UInt8]) {
        FfiConverterTypeZcashTransparentAddress.write(value.transparentAddress, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeZcashTransparentAddressAndIndex_lift(_ buf: RustBuffer) throws -> ZcashTransparentAddressAndIndex {
    return try FfiConverterTypeZcashTransparentAddressAndIndex.lift(buf)
}

public func FfiConverterTypeZcashTransparentAddressAndIndex_lower(_ value: ZcashTransparentAddressAndIndex) -> RustBuffer {
    return FfiConverterTypeZcashTransparentAddressAndIndex.lower(value)
}

public struct ZcashUnifiedAddressAndDiversifierIndex {
    public var address: ZcashUnifiedAddress
    public var diversifierIndex: ZcashDiversifierIndex

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: ZcashUnifiedAddress, diversifierIndex: ZcashDiversifierIndex) {
        self.address = address
        self.diversifierIndex = diversifierIndex
    }
}

public struct FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedAddressAndDiversifierIndex {
        return try ZcashUnifiedAddressAndDiversifierIndex(
            address: FfiConverterTypeZcashUnifiedAddress.read(from: &buf),
            diversifierIndex: FfiConverterTypeZcashDiversifierIndex.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashUnifiedAddressAndDiversifierIndex, into buf: inout [UInt8]) {
        FfiConverterTypeZcashUnifiedAddress.write(value.address, into: &buf)
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifierIndex, into: &buf)
    }
}

public func FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex_lift(_ buf: RustBuffer) throws -> ZcashUnifiedAddressAndDiversifierIndex {
    return try FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(buf)
}

public func FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex_lower(_ value: ZcashUnifiedAddressAndDiversifierIndex) -> RustBuffer {
    return FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashBranchId {
    case sprout

    case overwinter

    case sapling

    case blossom

    case heartwood

    case canopy

    case nu5
}

public struct FfiConverterTypeZcashBranchId: FfiConverterRustBuffer {
    typealias SwiftType = ZcashBranchId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBranchId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .sprout

        case 2: return .overwinter

        case 3: return .sapling

        case 4: return .blossom

        case 5: return .heartwood

        case 6: return .canopy

        case 7: return .nu5

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashBranchId, into buf: inout [UInt8]) {
        switch value {
        case .sprout:
            writeInt(&buf, Int32(1))

        case .overwinter:
            writeInt(&buf, Int32(2))

        case .sapling:
            writeInt(&buf, Int32(3))

        case .blossom:
            writeInt(&buf, Int32(4))

        case .heartwood:
            writeInt(&buf, Int32(5))

        case .canopy:
            writeInt(&buf, Int32(6))

        case .nu5:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeZcashBranchId_lift(_ buf: RustBuffer) throws -> ZcashBranchId {
    return try FfiConverterTypeZcashBranchId.lift(buf)
}

public func FfiConverterTypeZcashBranchId_lower(_ value: ZcashBranchId) -> RustBuffer {
    return FfiConverterTypeZcashBranchId.lower(value)
}

extension ZcashBranchId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashChildIndex {
    case nonHardened(v: UInt32)

    case hardened(v: UInt32)
}

public struct FfiConverterTypeZcashChildIndex: FfiConverterRustBuffer {
    typealias SwiftType = ZcashChildIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashChildIndex {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .nonHardened(
                v: FfiConverterUInt32.read(from: &buf)
            )

        case 2: return try .hardened(
                v: FfiConverterUInt32.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashChildIndex, into buf: inout [UInt8]) {
        switch value {
        case let .nonHardened(v):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v, into: &buf)

        case let .hardened(v):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(v, into: &buf)
        }
    }
}

public func FfiConverterTypeZcashChildIndex_lift(_ buf: RustBuffer) throws -> ZcashChildIndex {
    return try FfiConverterTypeZcashChildIndex.lift(buf)
}

public func FfiConverterTypeZcashChildIndex_lower(_ value: ZcashChildIndex) -> RustBuffer {
    return FfiConverterTypeZcashChildIndex.lower(value)
}

extension ZcashChildIndex: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashConsensusParameters {
    case mainNetwork

    case testNetwork
}

public struct FfiConverterTypeZcashConsensusParameters: FfiConverterRustBuffer {
    typealias SwiftType = ZcashConsensusParameters

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashConsensusParameters {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainNetwork

        case 2: return .testNetwork

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashConsensusParameters, into buf: inout [UInt8]) {
        switch value {
        case .mainNetwork:
            writeInt(&buf, Int32(1))

        case .testNetwork:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeZcashConsensusParameters_lift(_ buf: RustBuffer) throws -> ZcashConsensusParameters {
    return try FfiConverterTypeZcashConsensusParameters.lift(buf)
}

public func FfiConverterTypeZcashConsensusParameters_lower(_ value: ZcashConsensusParameters) -> RustBuffer {
    return FfiConverterTypeZcashConsensusParameters.lower(value)
}

extension ZcashConsensusParameters: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashFeeRules {
    case fixedStandard

    case fixedNonStandard(amount: UInt64)

    case zip317Standard

    case zip317NonStandard(marginalFee: UInt64, graceActions: UInt64, p2pkhStandardInputSize: UInt64, p2pkhStandardOutputSize: UInt64)
}

public struct FfiConverterTypeZcashFeeRules: FfiConverterRustBuffer {
    typealias SwiftType = ZcashFeeRules

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFeeRules {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .fixedStandard

        case 2: return try .fixedNonStandard(
                amount: FfiConverterUInt64.read(from: &buf)
            )

        case 3: return .zip317Standard

        case 4: return try .zip317NonStandard(
                marginalFee: FfiConverterUInt64.read(from: &buf),
                graceActions: FfiConverterUInt64.read(from: &buf),
                p2pkhStandardInputSize: FfiConverterUInt64.read(from: &buf),
                p2pkhStandardOutputSize: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashFeeRules, into buf: inout [UInt8]) {
        switch value {
        case .fixedStandard:
            writeInt(&buf, Int32(1))

        case let .fixedNonStandard(amount):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(amount, into: &buf)

        case .zip317Standard:
            writeInt(&buf, Int32(3))

        case let .zip317NonStandard(marginalFee, graceActions, p2pkhStandardInputSize, p2pkhStandardOutputSize):
            writeInt(&buf, Int32(4))
            FfiConverterUInt64.write(marginalFee, into: &buf)
            FfiConverterUInt64.write(graceActions, into: &buf)
            FfiConverterUInt64.write(p2pkhStandardInputSize, into: &buf)
            FfiConverterUInt64.write(p2pkhStandardOutputSize, into: &buf)
        }
    }
}

public func FfiConverterTypeZcashFeeRules_lift(_ buf: RustBuffer) throws -> ZcashFeeRules {
    return try FfiConverterTypeZcashFeeRules.lift(buf)
}

public func FfiConverterTypeZcashFeeRules_lower(_ value: ZcashFeeRules) -> RustBuffer {
    return FfiConverterTypeZcashFeeRules.lower(value)
}

extension ZcashFeeRules: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashKeySeed {
    case s128

    case s256

    case s512
}

public struct FfiConverterTypeZcashKeySeed: FfiConverterRustBuffer {
    typealias SwiftType = ZcashKeySeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashKeySeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .s128

        case 2: return .s256

        case 3: return .s512

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashKeySeed, into buf: inout [UInt8]) {
        switch value {
        case .s128:
            writeInt(&buf, Int32(1))

        case .s256:
            writeInt(&buf, Int32(2))

        case .s512:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeZcashKeySeed_lift(_ buf: RustBuffer) throws -> ZcashKeySeed {
    return try FfiConverterTypeZcashKeySeed.lift(buf)
}

public func FfiConverterTypeZcashKeySeed_lower(_ value: ZcashKeySeed) -> RustBuffer {
    return FfiConverterTypeZcashKeySeed.lower(value)
}

extension ZcashKeySeed: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashKeysEra {
    case orchard
}

public struct FfiConverterTypeZcashKeysEra: FfiConverterRustBuffer {
    typealias SwiftType = ZcashKeysEra

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashKeysEra {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .orchard

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashKeysEra, into buf: inout [UInt8]) {
        switch value {
        case .orchard:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeZcashKeysEra_lift(_ buf: RustBuffer) throws -> ZcashKeysEra {
    return try FfiConverterTypeZcashKeysEra.lift(buf)
}

public func FfiConverterTypeZcashKeysEra_lower(_ value: ZcashKeysEra) -> RustBuffer {
    return FfiConverterTypeZcashKeysEra.lower(value)
}

extension ZcashKeysEra: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashOrchardScope {
    case external

    case `internal`
}

public struct FfiConverterTypeZcashOrchardScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardScope

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardScope {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .external

        case 2: return .internal

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashOrchardScope, into buf: inout [UInt8]) {
        switch value {
        case .external:
            writeInt(&buf, Int32(1))

        case .internal:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeZcashOrchardScope_lift(_ buf: RustBuffer) throws -> ZcashOrchardScope {
    return try FfiConverterTypeZcashOrchardScope.lift(buf)
}

public func FfiConverterTypeZcashOrchardScope_lower(_ value: ZcashOrchardScope) -> RustBuffer {
    return FfiConverterTypeZcashOrchardScope.lower(value)
}

extension ZcashOrchardScope: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashRseed {
    case beforeZip212(frData: [UInt8])

    case afterZip212(data: [UInt8])
}

public struct FfiConverterTypeZcashRseed: FfiConverterRustBuffer {
    typealias SwiftType = ZcashRseed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashRseed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .beforeZip212(
                frData: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 2: return try .afterZip212(
                data: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashRseed, into buf: inout [UInt8]) {
        switch value {
        case let .beforeZip212(frData):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(frData, into: &buf)

        case let .afterZip212(data):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(data, into: &buf)
        }
    }
}

public func FfiConverterTypeZcashRseed_lift(_ buf: RustBuffer) throws -> ZcashRseed {
    return try FfiConverterTypeZcashRseed.lift(buf)
}

public func FfiConverterTypeZcashRseed_lower(_ value: ZcashRseed) -> RustBuffer {
    return FfiConverterTypeZcashRseed.lower(value)
}

extension ZcashRseed: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashScope {
    case external

    case `internal`
}

public struct FfiConverterTypeZcashScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashScope

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashScope {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .external

        case 2: return .internal

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashScope, into buf: inout [UInt8]) {
        switch value {
        case .external:
            writeInt(&buf, Int32(1))

        case .internal:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeZcashScope_lift(_ buf: RustBuffer) throws -> ZcashScope {
    return try FfiConverterTypeZcashScope.lift(buf)
}

public func FfiConverterTypeZcashScope_lower(_ value: ZcashScope) -> RustBuffer {
    return FfiConverterTypeZcashScope.lower(value)
}

extension ZcashScope: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashTxVersionSelection {
    case sprout(v: UInt32)

    case overwinter

    case sapling

    case zip225
}

public struct FfiConverterTypeZcashTxVersionSelection: FfiConverterRustBuffer {
    typealias SwiftType = ZcashTxVersionSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxVersionSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .sprout(
                v: FfiConverterUInt32.read(from: &buf)
            )

        case 2: return .overwinter

        case 3: return .sapling

        case 4: return .zip225

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashTxVersionSelection, into buf: inout [UInt8]) {
        switch value {
        case let .sprout(v):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v, into: &buf)

        case .overwinter:
            writeInt(&buf, Int32(2))

        case .sapling:
            writeInt(&buf, Int32(3))

        case .zip225:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeZcashTxVersionSelection_lift(_ buf: RustBuffer) throws -> ZcashTxVersionSelection {
    return try FfiConverterTypeZcashTxVersionSelection.lift(buf)
}

public func FfiConverterTypeZcashTxVersionSelection_lower(_ value: ZcashTxVersionSelection) -> RustBuffer {
    return FfiConverterTypeZcashTxVersionSelection.lower(value)
}

extension ZcashTxVersionSelection: Equatable, Hashable {}

public enum ZcashError {
    // Simple error enums only carry a message
    case HdWalletError(message: String)

    // Simple error enums only carry a message
    case DecodingError(message: String)

    // Simple error enums only carry a message
    case DerivationError(message: String)

    // Simple error enums only carry a message
    case InvalidAsk(message: String)

    // Simple error enums only carry a message
    case InvalidNsk(message: String)

    // Simple error enums only carry a message
    case Message(message: String)

    // Simple error enums only carry a message
    case ArrayLengthMismatch(message: String)

    // Simple error enums only carry a message
    case ValueOutOfRange(message: String)

    // Simple error enums only carry a message
    case Secp256k1Error(message: String)

    // Simple error enums only carry a message
    case Bech32DecodeError(message: String)

    // Simple error enums only carry a message
    case Bs58Error(message: String)

    // Simple error enums only carry a message
    case BuilderError(message: String)

    // Simple error enums only carry a message
    case TransparentBuilderError(message: String)

    // Simple error enums only carry a message
    case SaplingBuilderError(message: String)

    // Simple error enums only carry a message
    case OrchardBuilderError(message: String)

    // Simple error enums only carry a message
    case InsufficientFundsError(message: String)

    // Simple error enums only carry a message
    case ChangeRequiredError(message: String)

    // Simple error enums only carry a message
    case BalanceError(message: String)

    // Simple error enums only carry a message
    case IoError(message: String)

    // Simple error enums only carry a message
    case Unknown(message: String)
}

public struct FfiConverterTypeZcashError: FfiConverterRustBuffer {
    typealias SwiftType = ZcashError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .HdWalletError(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .DecodingError(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .DerivationError(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .InvalidAsk(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvalidNsk(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .Message(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .ArrayLengthMismatch(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .ValueOutOfRange(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .Secp256k1Error(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .Bech32DecodeError(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .Bs58Error(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .BuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 13: return try .TransparentBuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 14: return try .SaplingBuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 15: return try .OrchardBuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 16: return try .InsufficientFundsError(
                message: FfiConverterString.read(from: &buf)
            )

        case 17: return try .ChangeRequiredError(
                message: FfiConverterString.read(from: &buf)
            )

        case 18: return try .BalanceError(
                message: FfiConverterString.read(from: &buf)
            )

        case 19: return try .IoError(
                message: FfiConverterString.read(from: &buf)
            )

        case 20: return try .Unknown(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashError, into buf: inout [UInt8]) {
        switch value {
        case let .HdWalletError(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .DecodingError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .DerivationError(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidAsk(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidNsk(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .Message(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
        case let .ArrayLengthMismatch(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
        case let .ValueOutOfRange(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
        case let .Secp256k1Error(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
        case let .Bech32DecodeError(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
        case let .Bs58Error(message):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(message, into: &buf)
        case let .BuilderError(message):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(message, into: &buf)
        case let .TransparentBuilderError(message):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(message, into: &buf)
        case let .SaplingBuilderError(message):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(message, into: &buf)
        case let .OrchardBuilderError(message):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(message, into: &buf)
        case let .InsufficientFundsError(message):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(message, into: &buf)
        case let .ChangeRequiredError(message):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(message, into: &buf)
        case let .BalanceError(message):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(message, into: &buf)
        case let .IoError(message):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(message, into: &buf)
        case let .Unknown(message):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(message, into: &buf)
        }
    }
}

extension ZcashError: Equatable, Hashable {}

extension ZcashError: Error {}

private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashAccountPubKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashAccountPubKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashAccountPubKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashAccountPubKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashDiversifiableFullViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDiversifiableFullViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashDiversifiableFullViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashDiversifiableFullViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashMemoBytes: FfiConverterRustBuffer {
    typealias SwiftType = ZcashMemoBytes?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashMemoBytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashMemoBytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardBundle: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardBundle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardBundle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardBundle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardDiversifierIndex: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardDiversifierIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardDiversifierIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardDiversifierIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardFullViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardFullViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardFullViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardFullViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardOutgoingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardOutgoingViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardOutgoingViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOutgoingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOutgoingViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOutgoingViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOutgoingViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashPaymentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashPaymentAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashPaymentAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashPaymentAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashSaplingBundle: FfiConverterRustBuffer {
    typealias SwiftType = ZcashSaplingBundle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashSaplingBundle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashSaplingBundle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashSaplingMerklePath: FfiConverterRustBuffer {
    typealias SwiftType = ZcashSaplingMerklePath?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashSaplingMerklePath.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashSaplingMerklePath.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashTransparentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashTransparentAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashTransparentAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashTransparentAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashTransparentBundle: FfiConverterRustBuffer {
    typealias SwiftType = ZcashTransparentBundle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashTransparentBundle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashTransparentBundle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashUnifiedAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashUnifiedAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashUnifiedAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashUnifiedAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashDiversifierIndexAndPaymentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDiversifierIndexAndPaymentAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashDiversifierIndexAndScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDiversifierIndexAndScope?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashDiversifierIndexAndScope.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashDiversifierIndexAndScope.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashUnifiedAddressAndDiversifierIndex: FfiConverterRustBuffer {
    typealias SwiftType = ZcashUnifiedAddressAndDiversifierIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardScope?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardScope.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardScope.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardAction: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardAction]

    public static func write(_ value: [ZcashOrchardAction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardAction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardAction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardAction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardAction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardIncomingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardIncomingViewingKey]

    public static func write(_ value: [ZcashOrchardIncomingViewingKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardIncomingViewingKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardIncomingViewingKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardIncomingViewingKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardIncomingViewingKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardMerkleHash: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardMerkleHash]

    public static func write(_ value: [ZcashOrchardMerkleHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardMerkleHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardMerkleHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardMerkleHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardMerkleHash.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardOutgoingViewingKey]

    public static func write(_ value: [ZcashOrchardOutgoingViewingKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardOutgoingViewingKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardOutgoingViewingKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardOutgoingViewingKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardSpendingKey: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardSpendingKey]

    public static func write(_ value: [ZcashOrchardSpendingKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardSpendingKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardSpendingKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardSpendingKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardSpendingKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashSaplingOutputDescription: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashSaplingOutputDescription]

    public static func write(_ value: [ZcashSaplingOutputDescription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashSaplingOutputDescription.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashSaplingOutputDescription] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashSaplingOutputDescription]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashSaplingOutputDescription.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashSaplingSpendDescription: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashSaplingSpendDescription]

    public static func write(_ value: [ZcashSaplingSpendDescription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashSaplingSpendDescription.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashSaplingSpendDescription] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashSaplingSpendDescription]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashSaplingSpendDescription.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashTxIn: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashTxIn]

    public static func write(_ value: [ZcashTxIn], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashTxIn.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashTxIn] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashTxIn]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashTxIn.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashTxOut: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashTxOut]

    public static func write(_ value: [ZcashTxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashTxOut.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashTxOut] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashTxOut]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashTxOut.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashAuthPath: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashAuthPath]

    public static func write(_ value: [ZcashAuthPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashAuthPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashAuthPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashAuthPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashAuthPath.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardDecryptOutputForIncomingKeys]

    public static func write(_ value: [ZcashOrchardDecryptOutputForIncomingKeys], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardDecryptOutputForIncomingKeys] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardDecryptOutputForIncomingKeys]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardDecryptOutputForOutgoingKeys]

    public static func write(_ value: [ZcashOrchardDecryptOutputForOutgoingKeys], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardDecryptOutputForOutgoingKeys] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardDecryptOutputForOutgoingKeys]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashPaymentParam: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashPaymentParam]

    public static func write(_ value: [ZcashPaymentParam], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashPaymentParam.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashPaymentParam] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashPaymentParam]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashPaymentParam.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashChildIndex: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashChildIndex]

    public static func write(_ value: [ZcashChildIndex], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashChildIndex.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashChildIndex] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashChildIndex]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashChildIndex.read(from: &buf))
        }
        return seq
    }
}

public func decodeExtendedFullViewingKey(hrp: String, s: String) throws -> ZcashExtendedFullViewingKey {
    return try FfiConverterTypeZcashExtendedFullViewingKey.lift(
        rustCallWithError(FfiConverterTypeZcashError.self) {
            zcash_e53_decode_extended_full_viewing_key(
                FfiConverterString.lower(hrp),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func decodeExtendedSpendingKey(hrp: String, s: String) throws -> ZcashExtendedSpendingKey {
    return try FfiConverterTypeZcashExtendedSpendingKey.lift(
        rustCallWithError(FfiConverterTypeZcashError.self) {
            zcash_e53_decode_extended_spending_key(
                FfiConverterString.lower(hrp),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func decodePaymentAddress(hrp: String, s: String) throws -> ZcashPaymentAddress {
    return try FfiConverterTypeZcashPaymentAddress.lift(
        rustCallWithError(FfiConverterTypeZcashError.self) {
            zcash_e53_decode_payment_address(
                FfiConverterString.lower(hrp),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func decodeTransparentAddress(pubkeyVersion: [UInt8], scriptVersion: [UInt8], s: String) throws -> ZcashTransparentAddress {
    return try FfiConverterTypeZcashTransparentAddress.lift(
        rustCallWithError(FfiConverterTypeZcashError.self) {
            zcash_e53_decode_transparent_address(
                FfiConverterSequenceUInt8.lower(pubkeyVersion),
                FfiConverterSequenceUInt8.lower(scriptVersion),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func encodeExtendedFullViewingKey(hrp: String, extfvk: ZcashExtendedFullViewingKey) -> String {
    return try! FfiConverterString.lift(
        try!

            rustCall {
                zcash_e53_encode_extended_full_viewing_key(
                    FfiConverterString.lower(hrp),
                    FfiConverterTypeZcashExtendedFullViewingKey.lower(extfvk), $0
                )
            }
    )
}

public func encodeExtendedSpendingKey(hrp: String, extsk: ZcashExtendedSpendingKey) -> String {
    return try! FfiConverterString.lift(
        try!

            rustCall {
                zcash_e53_encode_extended_spending_key(
                    FfiConverterString.lower(hrp),
                    FfiConverterTypeZcashExtendedSpendingKey.lower(extsk), $0
                )
            }
    )
}

public func encodePaymentAddress(hrp: String, addr: ZcashPaymentAddress) -> String {
    return try! FfiConverterString.lift(
        try!

            rustCall {
                zcash_e53_encode_payment_address(
                    FfiConverterString.lower(hrp),
                    FfiConverterTypeZcashPaymentAddress.lower(addr), $0
                )
            }
    )
}

public func encodePaymentAddressP(params: ZcashConsensusParameters, addr: ZcashPaymentAddress) -> String {
    return try! FfiConverterString.lift(
        try!

            rustCall {
                zcash_e53_encode_payment_address_p(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterTypeZcashPaymentAddress.lower(addr), $0
                )
            }
    )
}

public func encodeTransparentAddress(pubkeyVersion: [UInt8], scriptVersion: [UInt8], addr: ZcashTransparentAddress) -> String {
    return try! FfiConverterString.lift(
        try!

            rustCall {
                zcash_e53_encode_transparent_address(
                    FfiConverterSequenceUInt8.lower(pubkeyVersion),
                    FfiConverterSequenceUInt8.lower(scriptVersion),
                    FfiConverterTypeZcashTransparentAddress.lower(addr), $0
                )
            }
    )
}

public func encodeTransparentAddressP(params: ZcashConsensusParameters, addr: ZcashTransparentAddress) -> String {
    return try! FfiConverterString.lift(
        try!

            rustCall {
                zcash_e53_encode_transparent_address_p(
                    FfiConverterTypeZcashConsensusParameters.lower(params),
                    FfiConverterTypeZcashTransparentAddress.lower(addr), $0
                )
            }
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum ZcashLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {}
}
